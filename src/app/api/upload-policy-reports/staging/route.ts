// API ROUTE: /api/upload-policy-reports/staging
// This endpoint handles parsing CSV files and uploading them to the policy_report_staging table
// Supports AMAM (American Amicable), RNA (Royal Neighbors), Combined policy reports, AHL (American Home Life) Excel files, Aflac Excel files, and Aetna Excel files

import { createServerClient, createAdminClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Papa from 'papaparse'  // For CSV parsing
import * as XLSX from 'xlsx'  // For Excel parsing

// TypeScript interface matching the policy_report_staging table structure
export interface PolicyReportStaging {
  // id is auto-generated by the database, so we don't include it in our interface
  client_name: string | null
  policy_number: string | null
  writing_agent_number: string | null
  agent_name: string | null
  status: string | null
  policy_effective_date: string | null // Will be converted to date format
  product?: string | null
  date_of_birth?: string | null
  issue_age?: number | null
  face_value?: number | null
  payment_method?: string | null
  payment_frequency?: string | null
  payment_cycle_premium?: number | null
  client_address?: string | null
  client_phone?: string | null
  client_email?: string | null
  state?: string | null
  zipcode?: string | null
  annual_premium?: number | null
  client_gender?: string | null
  agency_id: string
  carrier_name: string
}

// AMAM-specific CSV structure interface
interface AMAMPolicyData {
  WritingAgent: string;
  AgentName: string;
  Company: string;
  Policy: string;
  Status: string;        // ← Used for persistency impact
  DOB: string;
  PolicyDate: string;    // ← Used for time buckets
  PaidtoDate: string;    // ← Used for DeathClaim calculation
  RecvDate: string;
  LastName: string;
  FirstName: string;
  MI: string;
  Plan: string;
  Face: string;
  Form: string;
  Mode: string;
  ModePrem: string;
  Address1: string;
  Address2: string;
  Address3: string;
  Address4: string;
  State: string;
  Zip: string;
  Phone: string;
  Email: string;
  'App Date': string;
  WrtPct: string;
}

// RNA-specific CSV structure interface
interface RNAPolicyData {
  Agents: string;                    // Format: "agent_code - agent_name"
  InsuredName_Txt: string;           // Fully capitalized name
  OwnerName: string;                 // Fully capitalized name
  CertificateNumber1: string;         // Policy number
  Insured: string;                   // Product type
  Payor: string;                      // Payment information
  CurrentContractStatusReason1: string; // Policy status
  ApplicationEntryDate1: string;      // MM/DD/YYYY format
  ActivationDate1: string;           // MM/DD/YYYY format
}

// Combined-specific CSV structure interface
interface CombinedPolicyData {
  policy_number: string;
  insured_id: string;
  first_name: string;
  last_name: string;
  gender: string;                    // M / F format
  product: string;
  state_of_issue: string;
  issue_age: string;
  face_amount: string;
  mode: string;                      // Payment frequency (e.g., "Monthly")
  modal_premium: string;
  annual_premium: string;
  base_premium: string;
  rider_premium: string;
  commissionable_premium: string;
  split: string;
  app_date: string;                  // YYYY-MM-DD format
  issue_date: string;                // YYYY-MM-DD format
  effective_date: string;            // YYYY-MM-DD format
  termination_date: string;          // YYYY-MM-DD format
  status: string;
  writing_contract_id: string;
  writing_agent: string;             // Format: "first name last name"
  writing_number: string;
  npn: string;                       // Required for Combined identification
  owned: string;                     // Required for Combined identification
}

// AHL-specific Excel structure interface
interface AHLPolicyData {
  COMPANYCODE: string;
  POLICYNUMBER: string;
  STATUSCATEGORY: string;
  STATUSDISPLAYTEXT: string;
  PRODUCT: string;
  'APP TYPE': string;
  APPRECDDATE: string;
  APPSIGNATUREDATE: string;
  ORIGEFFDATE: string;
  PAIDTODATE: string;
  ISSUEDATE: string;
  TERMDATE: string;
  ISSUEDPREMIUM: string;
  CURRENTANNUALPREMIUM: string;
  CURRENTMODALPREMIUM: string;
  DRAFTDAY: string;
  PAYMENTMODEDISPLAYTEXT: string;
  PAYMENTMETHODDISPLAYTEXT: string;
  LASTPAYMENTDATE: string;
  LASTPAYAMT: string;
  ISSUEZIP: string;
  REPLACEMENTIND: string;
  REPLCOMPANYCODE: string;
  REPLPOLICYNUMBER: string;
  FACEVALUE: string;
  ISSUESTATE: string;
  'HOUSEHOLD DISCOUNT %': string;
  'MULTIPLE POLICY DISCOUNT %': string;
  LONGDESCRIPTION: string;
  INSUREDNAME: string;
  SUFFIXTITLE: string;
  SEX: string;
  BIRTHDATE: string;
  ADDRESSLINE1: string;
  ADDRESSLINE2: string;
  ADDRESSLINE3: string;
  CITY: string;
  STATE: string;
  POSTALCODE: string;
  PHONE1: string;
  EMAIL: string;
  ISSUEAGE: string;
  AGENTNUMBER: string;
  AGENTCOMPLETENAME: string;
  SPLITLEVEL: string;
  'SPLIT %': string;
}

// Aflac-specific Excel structure interface
interface AflacPolicyData {
  COMPANYCODE: string;
  POLICYNUMBER: string;
  STATUSCATEGORY: string;
  STATUSDISPLAYTEXT: string;
  PRODUCT: string;
  'APP TYPE': string;
  APPRECDDATE: string;
  APPSIGNATUREDATE: string;
  ORIGEFFDATE: string;
  PAIDTODATE: string;
  ISSUEDATE: string;
  TERMDATE: string;
  ISSUEDPREMIUM: string;
  CURRENTANNUALPREMIUM: string;
  CURRENTMODALPREMIUM: string;
  DRAFTDAY: string;
  PAYMENTMODEDISPLAYTEXT: string;
  PAYMENTMETHODDISPLAYTEXT: string;
  LASTPAYMENTDATE: string;
  LASTPAYAMT: string;
  ISSUEZIP: string;
  REPLACEMENTIND: string;
  REPLCOMPANYCODE: string;
  REPLPOLICYNUMBER: string;
  FACEVALUE: string;
  ISSUESTATE: string;
  'HOUSEHOLD DISCOUNT %': string;
  'MULTIPLE POLICY DISCOUNT %': string;
  LONGDESCRIPTION: string;
  INSUREDNAME: string;
  SUFFIXTITLE: string;
  SEX: string;
  BIRTHDATE: string;
  ADDRESSLINE1: string;
  ADDRESSLINE2: string;
  ADDRESSLINE3: string;
  CITY: string;
  STATE: string;
  POSTALCODE: string;
  PHONE1: string;
  EMAIL: string;
  ISSUEAGE: string;
  AGENTNUMBER: string;
  AGENTCOMPLETENAME: string;
  SPLITLEVEL: string;
  'SPLIT %': string;
}

// Aetna-specific Excel structure interface
interface AetnaPolicyData {
  COMPANYCODE: string;
  POLICYNUMBER: string;
  STATUSCATEGORY: string;
  STATUSDISPLAYTEXT: string;
  PRODUCT: string;
  'APP TYPE': string;
  APPRECDDATE: string;
  APPSIGNATUREDATE: string;
  ORIGEFFDATE: string;
  PAIDTODATE: string;
  ISSUEDATE: string;
  TERMDATE: string;
  ISSUEDPREMIUM: string;
  CURRENTANNUALPREMIUM: string;
  CURRENTMODALPREMIUM: string;
  DRAFTDAY: string;
  PAYMENTMODEDISPLAYTEXT: string;
  PAYMENTMETHODDISPLAYTEXT: string;
  LASTPAYMENTDATE: string;
  LASTPAYAMT: string;
  ISSUEZIP: string;
  REPLACEMENTIND: string;
  REPLCOMPANYCODE: string;
  REPLPOLICYNUMBER: string;
  FACEVALUE: string;
  ISSUESTATE: string;
  'HOUSEHOLD DISCOUNT %': string;
  'MULTIPLE POLICY DISCOUNT %': string;
  LONGDESCRIPTION: string;
  INSUREDNAME: string;
  SUFFIXTITLE: string;
  SEX: string;
  BIRTHDATE: string;
  ADDRESSLINE1: string;
  ADDRESSLINE2: string;
  ADDRESSLINE3: string;
  CITY: string;
  STATE: string;
  POSTALCODE: string;
  PHONE1: string;
  EMAIL: string;
  ISSUEAGE: string;
  AGENTNUMBER: string;
  AGENTCOMPLETENAME: string;
  SPLITLEVEL: string;
  'SPLIT %': string;
}

/**
 * Retrieves the agency ID for the current user
 *
 * @param supabase - Supabase client instance
 * @param userId - The authenticated user's ID (auth_user_id)
 * @returns Promise<string> - The agency ID
 */
async function getAgencyId(supabase: any, userId: string): Promise<string> {
  try {
    const { data: user, error } = await supabase
      .from('users')
      .select('agency_id')
      .eq('auth_user_id', userId)
      .single()

    if (error || !user) {
      throw new Error('Failed to fetch user agency')
    }

    if (!user.agency_id) {
      throw new Error('User is not associated with an agency')
    }

    return user.agency_id
  } catch (error) {
    console.error('Error fetching agency ID:', error)
    throw error instanceof Error ? error : new Error('Failed to retrieve agency ID')
  }
}

/**
 * Validates the uploaded file to ensure it meets requirements
 * Checks file type, size, and basic structure
 * Supports CSV files for AMAM, RNA, Combined and Excel files for AHL and Aflac
 * 
 * @param file - The uploaded file object
 * @returns Promise<boolean> - True if file is valid
 */
async function validateFile(file: File): Promise<boolean> {
  try {
    // Check file type - allow CSV files and Excel files
    const allowedTypes = ['text/csv', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet']
    
    if (!allowedTypes.includes(file.type)) {
      throw new Error(`Invalid file type: ${file.type}. Only CSV and Excel files are allowed for staging.`)
    }

    // Check file size - limit to 10MB
    const maxSize = 10 * 1024 * 1024 // 10MB in bytes
    if (file.size > maxSize) {
      throw new Error(`File size exceeds limit. Maximum size is 10MB.`)
    }

    // Check if file has content
    if (file.size === 0) {
      throw new Error('File is empty')
    }

    return true
  } catch (error) {
    console.error('File validation error:', error)
    throw error
  }
}

/**
 * Validates AMAM CSV structure and checks for required columns
 *
 * @param headers - Array of column headers from CSV
 * @returns {isValid: boolean, error?: string}
 */
function validateAMAMCSVStructure(headers: string[]): {isValid: boolean, error?: string} {
  // Check if Company column exists and contains AMAM data
  const companyIndex = headers.findIndex(h => h.toLowerCase().includes('company'))
  if (companyIndex === -1) {
    return { isValid: false, error: 'Failed to parse policy report, missing Company column' }
  }

  // Required columns for AMAM policy reports
  const requiredColumns = [
    'WritingAgent', 'AgentName', 'Policy', 'Status', 'DOB', 'PolicyDate',
    'LastName', 'FirstName', 'Plan', 'Face', 'Form', 'Mode', 'ModePrem',
    'Address1', 'State', 'Zip', 'Phone'
  ]

  const missingColumns = requiredColumns.filter(col =>
    !headers.some(header => header.toLowerCase() === col.toLowerCase())
  )

  if (missingColumns.length > 0) {
    return {
      isValid: false,
      error: `Failed to parse policy report, missing columns: ${missingColumns.join(', ')}`
    }
  }

  return { isValid: true }
}

/**
 * Formats agent name from "LastName/FirstName Middle Initial" to "FirstName Middle Initial LastName"
 *
 * @param agentName - The agent name in AMAM format
 * @returns string - Formatted agent name
 */
function formatAgentName(agentName: string): string {
  if (!agentName || agentName.trim() === '') return ''

  // Split by slash to separate last name and first name + middle initial
  const parts = agentName.split('/')
  if (parts.length !== 2) return agentName // Return original if format is unexpected

  const lastName = parts[0].trim()
  const firstNameAndMI = parts[1].trim()

  // Capitalize only first letter of each word
  const capitalizeWords = (str: string) =>
    str.toLowerCase().split(' ').map(word =>
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ')

  return `${capitalizeWords(firstNameAndMI)} ${capitalizeWords(lastName)}`
}

/**
 * Converts MM/DD/YYYY date string to YYYY-MM-DD format
 *
 * @param dateString - Date in MM/DD/YYYY format
 * @returns string - Date in YYYY-MM-DD format or empty string if invalid
 */
function convertDateFormat(dateString: string): string {
  if (!dateString || dateString.trim() === '') return ''

  try {
    // Parse MM/DD/YYYY format
    const parts = dateString.split('/')
    if (parts.length !== 3) return ''

    const month = parts[0].padStart(2, '0')
    const day = parts[1].padStart(2, '0')
    const year = parts[2]

    // Validate date
    const date = new Date(`${year}-${month}-${day}`)
    if (isNaN(date.getTime())) return ''

    return `${year}-${month}-${day}`
  } catch (error) {
    return ''
  }
}

/**
 * Calculates issue age from policy date and date of birth
 *
 * @param policyDate - Policy effective date
 * @param dob - Date of birth
 * @returns number | null - Age in years, rounded to nearest whole number
 */
function calculateIssueAge(policyDate: string, dob: string): number | null {
  if (!policyDate || !dob) return null

  try {
    const policy = new Date(policyDate)
    const birth = new Date(dob)

    if (isNaN(policy.getTime()) || isNaN(birth.getTime())) return null

    const ageInMs = policy.getTime() - birth.getTime()
    const ageInYears = ageInMs / (365.25 * 24 * 60 * 60 * 1000) // Account for leap years

    return Math.round(ageInYears)
  } catch (error) {
    return null
  }
}

/**
 * Safely converts string to number, removing commas and dollar signs
 *
 * @param value - String value to convert
 * @returns number | null - Converted number or null if invalid
 */
function toNumber(value: string): number | null {
  if (!value || value.trim() === '') return null
  const num = parseFloat(value.replace(/[,$]/g, ''))
  return isNaN(num) ? null : num
}

/**
 * Builds client address from address components
 *
 * @param address1 - First address line
 * @param address2 - Second address line
 * @param address3 - Third address line
 * @param address4 - Fourth address line
 * @returns string | null - Combined address or null if all empty
 */
function buildClientAddress(address1: string, address2: string, address3: string, address4: string): string | null {
  const addressParts = [address1, address2, address3, address4]
    .filter(part => part && part.trim() !== '')
    .map(part => part.trim())

  return addressParts.length > 0 ? addressParts.join(' ') : null
}

/**
 * Standardizes client name capitalization - only first letter of each word capitalized
 *
 * @param firstName - First name
 * @param middleInitial - Middle initial
 * @param lastName - Last name
 * @returns string - Properly capitalized client name
 */
function standardizeClientName(firstName: string, middleInitial: string, lastName: string): string {
  const capitalizeWord = (word: string) => {
    if (!word || word.trim() === '') return ''
    return word.trim().toLowerCase().charAt(0).toUpperCase() + word.trim().toLowerCase().slice(1)
  }

  const parts = [
    capitalizeWord(firstName),
    capitalizeWord(middleInitial),
    capitalizeWord(lastName)
  ].filter(part => part !== '')

  return parts.join(' ')
}

/**
 * Normalizes payment frequency values
 *
 * @param mode - Payment mode/frequency value
 * @returns string | null - Normalized payment frequency
 */
function normalizePaymentFrequency(mode: string): string | null {
  if (!mode || mode.trim() === '') return null

  const normalizedMode = mode.trim().toLowerCase()

  // Standardize common variations
  if (normalizedMode.includes('monthly') || normalizedMode === 'month') {
    return 'Monthly'
  }
  if (normalizedMode.includes('quarterly') || normalizedMode === 'quarter') {
    return 'Quarterly'
  }
  if (normalizedMode.includes('semi') || normalizedMode.includes('semi-annual')) {
    return 'Semi-Annual'
  }
  if (normalizedMode.includes('annual') || normalizedMode === 'year') {
    return 'Annual'
  }

  // Return original value with proper capitalization if no match
  return mode.trim().charAt(0).toUpperCase() + mode.trim().slice(1).toLowerCase()
}

/**
 * Standardizes phone number - removes all non-numeric characters
 *
 * @param phone - Phone number string
 * @returns string | null - Cleaned phone number with only digits
 */
function standardizePhoneNumber(phone: string): string | null {
  if (!phone || phone.trim() === '') return null

  // Remove all non-numeric characters (dashes, spaces, parentheses, etc.)
  const cleanedPhone = phone.replace(/\D/g, '')

  // Return null if no digits found
  return cleanedPhone.length > 0 ? cleanedPhone : null
}

/**
 * Standardizes email - converts to lowercase
 *
 * @param email - Email string
 * @returns string | null - Lowercase email or null if empty
 */
function standardizeEmail(email: string): string | null {
  if (!email || email.trim() === '') return null

  return email.trim().toLowerCase()
}

/**
 * Cleans CSV values - removes =("value") syntax that appears in CSV data
 *
 * @param value - Value from CSV that might have =("value") format
 * @returns string - Cleaned value
 */
function cleanCSVValue(value: string): string {
  console.log(`Original CSV value: "${value}"`)

  if (!value || value.trim() === '') {
    console.log('Value is empty, returning empty string')
    return ''
  }

  const trimmedValue = value.trim()
  console.log(`Trimmed value: "${trimmedValue}"`)

  // Handle CSV format like =("0110097180")
  if (trimmedValue.match(/^=\("([^"]+)"\)$/)) {
    const match = trimmedValue.match(/^=\("([^"]+)"\)$/)
    const extractedValue = match ? match[1] : ''
    console.log(`Extracted value from CSV =("...") format: "${extractedValue}"`)
    return extractedValue
  }

  console.log(`Returning original value: "${trimmedValue}"`)
  return trimmedValue
}

/**
 * Parses AMAM CSV content and converts it to PolicyReportStaging objects
 *
 * @param csvContent - The CSV file content as string
 * @param carrierName - The carrier name
 * @param agencyId - The agency ID
 * @returns Promise<PolicyReportStaging[]> - Array of parsed policy reports
 */
async function parseAMAMCSVToPolicyReports(
  csvContent: string,
  carrierName: string,
  agencyId: string
): Promise<PolicyReportStaging[]> {
  try {
    // Parse CSV content using Papa Parse
    const parseResult = Papa.parse<AMAMPolicyData>(csvContent, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => header.trim()
    })

    if (parseResult.errors && parseResult.errors.length > 0) {
      console.error('Papa Parse errors:', parseResult.errors)
      throw new Error(`CSV parsing errors: ${parseResult.errors.map((e: any) => e.message).join(', ')}`)
    }

    const records = parseResult.data
    if (records.length === 0) {
      throw new Error('No data found in CSV file')
    }

    // Validate CSV structure
    const headers = Object.keys(records[0])
    const validation = validateAMAMCSVStructure(headers)
    if (!validation.isValid) {
      throw new Error(validation.error)
    }

    // Check if this is actually AMAM data by verifying Company column exists
    const firstRecord = records[0]
    if (!firstRecord.Company) {
      throw new Error('You uploaded the wrong company\'s policy report to the AMAM section')
    }

    // Map AMAM records to PolicyReportStaging objects
    const policyReports: PolicyReportStaging[] = []

    for (let i = 0; i < records.length; i++) {
      const record = records[i]

      try {
        // Check for required fields - TODO: Remove console.log when productionalizing
        const requiredFields = ['FirstName', 'LastName', 'Policy', 'WritingAgent', 'AgentName', 'Status', 'PolicyDate']
        const missingFields = requiredFields.filter(field => !record[field as keyof AMAMPolicyData] || record[field as keyof AMAMPolicyData].toString().trim() === '')

        if (missingFields.length > 0) {
          console.log(`Row ${i + 1} missing required fields: ${missingFields.join(', ')}`, record)
          continue // Skip this row but continue processing others
        }

        // Convert dates
        const policyDate = convertDateFormat(record.PolicyDate)
        const dobDate = convertDateFormat(record.DOB)

        // Calculate issue age
        const issueAge = calculateIssueAge(policyDate, dobDate)

        // Build client name with proper capitalization
        const clientName = standardizeClientName(record.FirstName, record.MI || '', record.LastName)

        // Format agent name
        const formattedAgentName = formatAgentName(record.AgentName)

        // Build address
        const clientAddress = buildClientAddress(record.Address1, record.Address2, record.Address3, record.Address4)

        // Normalize payment frequency
        const normalizedPaymentFrequency = normalizePaymentFrequency(record.Mode)

        // Standardize phone and email
        const standardizedPhone = standardizePhoneNumber(record.Phone)
        const standardizedEmail = standardizeEmail(record.Email)

        // Calculate annual premium
        const modePrem = toNumber(record.ModePrem)
        const annualPremium = modePrem ? modePrem * 12 : null

        const policyReport: PolicyReportStaging = {
          client_name: cleanValue(clientName),
          policy_number: cleanValue(cleanCSVValue(record.Policy)),
          writing_agent_number: cleanValue(cleanCSVValue(record.WritingAgent)),
          agent_name: cleanValue(formattedAgentName),
          status: cleanValue(record.Status),
          policy_effective_date: cleanValue(policyDate),
          product: cleanValue(record.Plan),
          date_of_birth: cleanValue(dobDate),
          issue_age: issueAge,
          face_value: toNumber(record.Face),
          payment_method: cleanValue(record.Form),
          payment_frequency: normalizedPaymentFrequency ? cleanValue(normalizedPaymentFrequency) : null,
          payment_cycle_premium: modePrem,
          client_address: clientAddress ? cleanValue(clientAddress) : null,
          client_phone: standardizedPhone ? cleanValue(standardizedPhone) : null,
          client_email: standardizedEmail ? cleanValue(standardizedEmail) : null,
          state: cleanValue(record.State),
          zipcode: cleanValue(record.Zip),
          annual_premium: annualPremium,
          client_gender: null, // No gender data in AMAM
          agency_id: agencyId,
          carrier_name: 'American Amicable / Occidental'
        }

        policyReports.push(policyReport)
      } catch (rowError) {
        console.error(`Error processing row ${i + 1}:`, rowError, record)
        // Continue processing other rows
      }
    }

    return policyReports
  } catch (error) {
    console.error('AMAM CSV parsing error:', error)
    throw new Error(`Failed to parse AMAM CSV: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Uploads policy reports to the staging table
 *
 * @param supabase - Supabase client instance
 * @param policyReports - Array of policy reports to insert
 * @returns Promise<{success: boolean, insertedCount?: number, error?: string}>
 */
async function uploadPolicyReportsToStaging(
  supabase: any,
  policyReports: PolicyReportStaging[]
): Promise<{success: boolean, insertedCount?: number, error?: string}> {
  try {
    // Insert policy reports into staging table
    const { data, error } = await supabase
      .from('policy_report_staging')
      .insert(policyReports)
      .select()

    if (error) {
      console.error('Database insert error:', error)
      return { success: false, error: error.message }
    }

    return {
      success: true,
      insertedCount: data?.length || policyReports.length
    }
  } catch (error) {
    console.error('Upload to staging error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error during staging upload'
    }
  }
}

// ============================================================================
// ROYAL NEIGHBORS (RNA) SPECIFIC FUNCTIONS
// ============================================================================

/**
 * RNA: Validates Royal Neighbors CSV structure and checks for required columns
 * 
 * @param headers - Array of column headers from CSV
 * @returns {isValid: boolean, error?: string}
 */
function validateRNACSVStructure(headers: string[]): {isValid: boolean, error?: string} {
  // Check if CertificateNumber1 column exists (required for RNA identification)
  const certificateNumberIndex = headers.findIndex(h => h.toLowerCase().includes('certificatenumber1'))
  if (certificateNumberIndex === -1) {
    return { isValid: false, error: 'Failed to parse policy report, missing CertificateNumber1 column - this does not appear to be a Royal Neighbors CSV' }
  }

  // Required columns for RNA policy reports
  const requiredColumns = [
    'Agents', 'InsuredName_Txt', 'OwnerName', 'CertificateNumber1', 
    'Insured', 'Payor', 'CurrentContractStatusReason1', 
    'ApplicationEntryDate1', 'ActivationDate1'
  ]

  const missingColumns = requiredColumns.filter(col => 
    !headers.some(header => header.toLowerCase() === col.toLowerCase())
  )

  if (missingColumns.length > 0) {
    return { 
      isValid: false, 
      error: `Failed to parse policy report, missing columns: ${missingColumns.join(', ')}` 
    }
  }

  return { isValid: true }
}

/**
 * RNA: Splits the Agents field into agent code and agent name
 * Expected format: "agent_code - agent_name"
 * 
 * @param agentsField - The Agents field from RNA CSV
 * @returns {agentCode: string, agentName: string}
 */
function splitRNAAgentsField(agentsField: string): {agentCode: string, agentName: string} {
  if (!agentsField || agentsField.trim() === '') {
    return { agentCode: '', agentName: '' }
  }
  
  // Split by " - " to separate agent code and agent name
  const parts = agentsField.split(' - ')
  if (parts.length !== 2) {
    // If format is unexpected, return original value as agent name
    return { agentCode: '', agentName: agentsField.trim() }
  }
  
  return {
    agentCode: parts[0].trim(),
    agentName: parts[1].trim()
  }
}

/**
 * RNA: Capitalizes first letter of each word in a name (converts from fully capitalized)
 * 
 * @param name - Fully capitalized name (e.g., "JOHN DOE")
 * @returns string - Properly capitalized name (e.g., "John Doe")
 */
function capitalizeRNAName(name: string): string {
  if (!name || name.trim() === '') return ''
  
  return name.trim()
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * Cleans empty strings and converts them to null for database storage
 * Applies to all carriers - ensures empty strings are stored as null
 * 
 * @param value - Value to clean
 * @returns string | null - Cleaned value or null if empty
 */
function cleanValue(value: string): string | null {
  if (!value || value.trim() === '') return null
  return value.trim()
}

/**
 * RNA: Parses Royal Neighbors CSV content and converts it to PolicyReportStaging objects
 * 
 * @param csvContent - The CSV file content as string
 * @param carrierName - The carrier name
 * @param agencyId - The agency ID
 * @returns Promise<PolicyReportStaging[]> - Array of parsed policy reports
 */
async function parseRNACSVToPolicyReports(
  csvContent: string, 
  carrierName: string, 
  agencyId: string
): Promise<PolicyReportStaging[]> {
  try {
    // Parse CSV content using Papa Parse
    const parseResult = Papa.parse<RNAPolicyData>(csvContent, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => header.trim()
    })

    if (parseResult.errors && parseResult.errors.length > 0) {
      console.error('Papa Parse errors:', parseResult.errors)
      throw new Error(`CSV parsing errors: ${parseResult.errors.map((e: any) => e.message).join(', ')}`)
    }

    const records = parseResult.data
    if (records.length === 0) {
      throw new Error('No data found in CSV file')
    }

    // Validate CSV structure
    const headers = Object.keys(records[0])
    const validation = validateRNACSVStructure(headers)
    if (!validation.isValid) {
      throw new Error(validation.error)
    }

    // Check if this is actually RNA data by verifying CertificateNumber1 column exists
    const firstRecord = records[0]
    if (!firstRecord.CertificateNumber1) {
      throw new Error('You uploaded the wrong company\'s policy report to the Royal Neighbors section')
    }

    // Map RNA records to PolicyReportStaging objects
    const policyReports: PolicyReportStaging[] = []
    
    for (let i = 0; i < records.length; i++) {
      const record = records[i]
      
      try {
        // Check for required fields
        const requiredFields = ['InsuredName_Txt', 'CertificateNumber1', 'Agents', 'CurrentContractStatusReason1', 'ActivationDate1']
        const missingFields = requiredFields.filter(field => !record[field as keyof RNAPolicyData] || record[field as keyof RNAPolicyData].toString().trim() === '')
        
        if (missingFields.length > 0) {
          console.log(`Row ${i + 1} missing required fields: ${missingFields.join(', ')}`, record)
          continue // Skip this row but continue processing others
        }

        // Split agent field into code and name
        const { agentCode, agentName } = splitRNAAgentsField(record.Agents)
        
        // Convert dates using existing AMAM function
        const policyDate = convertDateFormat(record.ActivationDate1)
        const applicationDate = convertDateFormat(record.ApplicationEntryDate1)
        
        // Capitalize names using RNA-specific function
        const clientName = capitalizeRNAName(record.InsuredName_Txt)
        const ownerName = capitalizeRNAName(record.OwnerName)
        const formattedAgentName = capitalizeRNAName(agentName)

        const policyReport: PolicyReportStaging = {
          client_name: cleanValue(clientName),
          policy_number: cleanValue(cleanCSVValue(record.CertificateNumber1)),
          writing_agent_number: cleanValue(agentCode),
          agent_name: cleanValue(formattedAgentName),
          status: cleanValue(record.CurrentContractStatusReason1),
          policy_effective_date: cleanValue(policyDate),
          product: cleanValue(record.Insured),
          date_of_birth: null, // No DOB data in RNA
          issue_age: null, // No DOB data in RNA
          face_value: null, // No face value data in RNA
          payment_method: null, // No payment method data in RNA
          payment_frequency: null, // No payment frequency data in RNA
          payment_cycle_premium: null, // No premium data in RNA
          client_address: null, // No address data in RNA
          client_phone: null, // No phone data in RNA
          client_email: null, // No email data in RNA
          state: null, // No state data in RNA
          zipcode: null, // No zipcode data in RNA
          annual_premium: null, // No premium data in RNA
          client_gender: null, // No gender data in RNA
          agency_id: agencyId,
          carrier_name: 'RNA'
        }

        policyReports.push(policyReport)
      } catch (rowError) {
        console.error(`Error processing row ${i + 1}:`, rowError, record)
        // Continue processing other rows
      }
    }

    return policyReports
  } catch (error) {
    console.error('RNA CSV parsing error:', error)
    throw new Error(`Failed to parse RNA CSV: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

// ============================================================================
// COMBINED SPECIFIC FUNCTIONS
// ============================================================================

/**
 * Combined: Validates Combined CSV structure and checks for required columns
 * Verifies that it is a CSV, contains data, and is a Combined CSV by checking for npn and owned columns
 * 
 * @param headers - Array of column headers from CSV
 * @returns {isValid: boolean, error?: string}
 */
function validateCombinedCSVStructure(headers: string[]): {isValid: boolean, error?: string} {
  // Check if npn column exists (required for Combined identification)
  const npnIndex = headers.findIndex(h => h.toLowerCase().includes('npn'))
  if (npnIndex === -1) {
    return { isValid: false, error: 'Failed to parse policy report, missing npn column - this does not appear to be a Combined CSV' }
  }

  // Check if owned column exists (required for Combined identification)
  const ownedIndex = headers.findIndex(h => h.toLowerCase().includes('owned'))
  if (ownedIndex === -1) {
    return { isValid: false, error: 'Failed to parse policy report, missing owned column - this does not appear to be a Combined CSV' }
  }

  // Required columns for Combined policy reports
  const requiredColumns = [
    'policy_number', 'insured_id', 'first_name', 'last_name', 'gender', 'product',
    'state_of_issue', 'issue_age', 'face_amount', 'mode', 'modal_premium', 'annual_premium',
    'base_premium', 'rider_premium', 'commissionable_premium', 'split', 'app_date',
    'issue_date', 'effective_date', 'termination_date', 'status', 'writing_contract_id',
    'writing_agent', 'writing_number', 'npn', 'owned'
  ]

  const missingColumns = requiredColumns.filter(col => 
    !headers.some(header => header.toLowerCase() === col.toLowerCase())
  )

  if (missingColumns.length > 0) {
    return { 
      isValid: false, 
      error: `Failed to parse policy report, missing columns: ${missingColumns.join(', ')}` 
    }
  }

  return { isValid: true }
}

/**
 * Combined: Capitalizes first letter of each word in a name field
 * Handles names separated by spaces - capitalizes first letter of each word, rest lowercase
 * 
 * @param name - Name field that may contain multiple words
 * @returns string - Properly capitalized name
 */
function capitalizeCombinedName(name: string): string {
  if (!name || name.trim() === '') return ''
  
  return name.trim()
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * Combined: Processes gender field - ensures M/F format with proper capitalization
 * 
 * @param gender - Gender value from CSV (M / F format)
 * @returns string | null - Properly formatted gender (M or F) or null if invalid
 */
function processCombinedGender(gender: string): string | null {
  if (!gender || gender.trim() === '') return null
  
  const trimmedGender = gender.trim().toUpperCase()
  
  // Accept M or F, with or without spaces/slashes
  if (trimmedGender === 'M' || trimmedGender === 'F') {
    return trimmedGender
  }
  
  // Handle formats like "M / F" or "M/F"
  if (trimmedGender.includes('M')) return 'M'
  if (trimmedGender.includes('F')) return 'F'
  
  return null
}

/**
 * Combined: Validates and converts date string to proper format
 * Dates should already be in YYYY-MM-DD format but validates and converts if needed
 * 
 * @param dateString - Date string from CSV
 * @returns string | null - Validated date in YYYY-MM-DD format or null if invalid
 */
function validateCombinedDate(dateString: string): string | null {
  if (!dateString || dateString.trim() === '') return null
  
  const trimmedDate = dateString.trim()
  
  // Check if already in YYYY-MM-DD format
  if (/^\d{4}-\d{2}-\d{2}$/.test(trimmedDate)) {
    // Validate the date
    const date = new Date(trimmedDate)
    if (!isNaN(date.getTime())) {
      return trimmedDate
    }
  }
  
  // Try to parse other common formats and convert to YYYY-MM-DD
  const date = new Date(trimmedDate)
  if (!isNaN(date.getTime())) {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const day = String(date.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }
  
  return null
}

/**
 * Combined: Parses Combined CSV content and converts it to PolicyReportStaging objects
 * 
 * @param csvContent - The CSV file content as string
 * @param carrierName - The carrier name
 * @param agencyId - The agency ID
 * @returns Promise<PolicyReportStaging[]> - Array of parsed policy reports
 */
async function parseCombinedCSVToPolicyReports(
  csvContent: string, 
  carrierName: string, 
  agencyId: string
): Promise<PolicyReportStaging[]> {
  try {
    // Parse CSV content using Papa Parse
    const parseResult = Papa.parse<CombinedPolicyData>(csvContent, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => header.trim()
    })

    if (parseResult.errors && parseResult.errors.length > 0) {
      console.error('Papa Parse errors:', parseResult.errors)
      throw new Error(`CSV parsing errors: ${parseResult.errors.map((e: any) => e.message).join(', ')}`)
    }

    const records = parseResult.data
    if (records.length === 0) {
      throw new Error('No data found in CSV file')
    }

    // Validate CSV structure
    const headers = Object.keys(records[0])
    const validation = validateCombinedCSVStructure(headers)
    if (!validation.isValid) {
      throw new Error(validation.error)
    }

    // Check if this is actually Combined data by verifying npn and owned columns exist
    const firstRecord = records[0]
    if (!firstRecord.npn || !firstRecord.owned) {
      throw new Error('You uploaded the wrong company\'s policy report to the Combined section')
    }

    // Map Combined records to PolicyReportStaging objects
    const policyReports: PolicyReportStaging[] = []
    
    for (let i = 0; i < records.length; i++) {
      const record = records[i]
      
      try {
        // Check for required fields
        const requiredFields = ['policy_number', 'first_name', 'last_name', 'writing_agent', 'writing_number', 'status', 'effective_date']
        const missingFields = requiredFields.filter(field => !record[field as keyof CombinedPolicyData] || record[field as keyof CombinedPolicyData].toString().trim() === '')
        
        if (missingFields.length > 0) {
          console.log(`Row ${i + 1} missing required fields: ${missingFields.join(', ')}`, record)
          continue // Skip this row but continue processing others
        }

        // Process names with proper capitalization
        const capitalizedFirstName = capitalizeCombinedName(record.first_name)
        const capitalizedLastName = capitalizeCombinedName(record.last_name)
        const capitalizedWritingAgent = capitalizeCombinedName(record.writing_agent)
        
        // Combine first and last name for client_name
        const clientName = `${capitalizedFirstName} ${capitalizedLastName}`.trim()
        
        // Process gender field
        const processedGender = processCombinedGender(record.gender)
        
        // Validate and convert dates
        const effectiveDate = validateCombinedDate(record.effective_date)
        const appDate = validateCombinedDate(record.app_date)
        const issueDate = validateCombinedDate(record.issue_date)
        const terminationDate = validateCombinedDate(record.termination_date)
        
        // Convert numeric fields
        const issueAge = toNumber(record.issue_age)
        const faceValue = toNumber(record.face_amount)
        const modalPremium = toNumber(record.modal_premium)
        const annualPremium = toNumber(record.annual_premium)
        
        // Normalize payment frequency using existing function
        const normalizedPaymentFrequency = normalizePaymentFrequency(record.mode)

        const policyReport: PolicyReportStaging = {
          client_name: cleanValue(clientName),
          policy_number: cleanValue(cleanCSVValue(record.policy_number)),
          writing_agent_number: cleanValue(cleanCSVValue(record.writing_number)),
          agent_name: cleanValue(capitalizedWritingAgent),
          status: cleanValue(record.status),
          policy_effective_date: effectiveDate ? cleanValue(effectiveDate) : null,
          product: cleanValue(record.product),
          date_of_birth: null, // No DOB data in Combined
          issue_age: issueAge,
          face_value: faceValue,
          payment_method: null, // No payment method data in Combined
          payment_frequency: normalizedPaymentFrequency ? cleanValue(normalizedPaymentFrequency) : null,
          payment_cycle_premium: modalPremium,
          client_address: null, // No address data in Combined
          client_phone: null, // No phone data in Combined
          client_email: null, // No email data in Combined
          state: cleanValue(record.state_of_issue),
          zipcode: null, // No zipcode data in Combined
          annual_premium: annualPremium,
          client_gender: processedGender ? cleanValue(processedGender) : null,
          agency_id: agencyId,
          carrier_name: 'Combined'
        }

        policyReports.push(policyReport)
      } catch (rowError) {
        console.error(`Error processing row ${i + 1}:`, rowError, record)
        // Continue processing other rows
      }
    }

    return policyReports
  } catch (error) {
    console.error('Combined CSV parsing error:', error)
    throw new Error(`Failed to parse Combined CSV: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

// ============================================================================
// AMERICAN HOME LIFE (AHL) SPECIFIC FUNCTIONS
// ============================================================================

/**
 * AHL: Validates American Home Life Excel file structure and checks for required columns
 * Verifies that it is an Excel file, contains data, and is an AHL Excel file by checking COMPANYCODE column
 * 
 * @param workbook - The Excel workbook object
 * @returns {isValid: boolean, error?: string, dataStartRow?: number}
 */
function validateAHLExcelStructure(workbook: XLSX.WorkBook): {isValid: boolean, error?: string, dataStartRow?: number} {
  try {
    // Get the first worksheet
    const sheetName = workbook.SheetNames[0]
    if (!sheetName) {
      return { isValid: false, error: 'No worksheets found in Excel file' }
    }
    
    const worksheet = workbook.Sheets[sheetName]
    if (!worksheet) {
      return { isValid: false, error: 'Unable to read worksheet' }
    }
    
    // Convert worksheet to JSON to find the data
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    if (!jsonData || jsonData.length === 0) {
      return { isValid: false, error: 'Excel file contains no data' }
    }
    
    // Find the row that contains the column headers
    let headerRowIndex = -1
    let headers: string[] = []
    
    for (let i = 0; i < jsonData.length; i++) {
      const row = jsonData[i] as string[]
      if (row && row.length > 0) {
        // Look for COMPANYCODE column to identify header row
        const companyCodeIndex = row.findIndex(cell => 
          cell && cell.toString().toUpperCase().includes('COMPANYCODE')
        )
        
        if (companyCodeIndex !== -1) {
          headerRowIndex = i
          headers = row.map(cell => cell ? cell.toString().trim() : '')
          break
        }
      }
    }
    
    if (headerRowIndex === -1) {
      return { isValid: false, error: 'Failed to parse policy report, missing COMPANYCODE column - this does not appear to be an AHL Excel file' }
    }
    
    // Required columns for AHL policy reports
    const requiredColumns = [
      'COMPANYCODE', 'POLICYNUMBER', 'STATUSCATEGORY', 'STATUSDISPLAYTEXT',
      'PRODUCT', 'APP TYPE', 'APPRECDDATE', 'APPSIGNATUREDATE', 'ORIGEFFDATE',
      'PAIDTODATE', 'ISSUEDATE', 'TERMDATE', 'ISSUEDPREMIUM',
      'CURRENTANNUALPREMIUM', 'CURRENTMODALPREMIUM', 'DRAFTDAY',
      'PAYMENTMODEDISPLAYTEXT', 'PAYMENTMETHODDISPLAYTEXT', 'LASTPAYMENTDATE',
      'LASTPAYAMT', 'ISSUEZIP', 'REPLACEMENTIND', 'REPLCOMPANYCODE',
      'REPLPOLICYNUMBER', 'FACEVALUE', 'ISSUESTATE', 'HOUSEHOLD DISCOUNT %',
      'MULTIPLE POLICY DISCOUNT %', 'LONGDESCRIPTION', 'INSUREDNAME',
      'SUFFIXTITLE', 'SEX', 'BIRTHDATE', 'ADDRESSLINE1', 'ADDRESSLINE2',
      'ADDRESSLINE3', 'CITY', 'STATE', 'POSTALCODE', 'PHONE1', 'EMAIL',
      'ISSUEAGE', 'AGENTNUMBER', 'AGENTCOMPLETENAME', 'SPLITLEVEL',
      'SPLIT %'
    ]
    
    const missingColumns = requiredColumns.filter(col => 
      !headers.some(header => header.toUpperCase() === col.toUpperCase())
    )
    
    if (missingColumns.length > 0) {
      return { 
        isValid: false, 
        error: `Failed to parse policy report, missing columns: ${missingColumns.join(', ')}` 
      }
    }
    
    return { isValid: true, dataStartRow: headerRowIndex + 1 }
  } catch (error) {
    return { isValid: false, error: `Error validating AHL Excel structure: ${error instanceof Error ? error.message : 'Unknown error'}` }
  }
}

/**
 * AHL: Verifies that the Excel file contains AHL data by checking COMPANYCODE values
 * 
 * @param workbook - The Excel workbook object
 * @param dataStartRow - The row where data starts (after headers)
 * @returns {isValid: boolean, error?: string}
 */
function verifyAHLData(workbook: XLSX.WorkBook, dataStartRow: number): {isValid: boolean, error?: string} {
  try {
    const sheetName = workbook.SheetNames[0]
    const worksheet = workbook.Sheets[sheetName]
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    // Determine header row and COMPANYCODE column index
    const headerRowIndex = dataStartRow - 1
    const headerRow = jsonData[headerRowIndex] as string[]
    if (!headerRow) {
      return { isValid: false, error: 'Unable to locate header row for AHL Excel' }
    }
    const companyCodeColIndex = headerRow.findIndex(h => String(h).toUpperCase().trim() === 'COMPANYCODE')
    if (companyCodeColIndex === -1) {
      return { isValid: false, error: 'COMPANYCODE column not found in AHL Excel headers' }
    }

    // Check a few random rows to verify COMPANYCODE contains "AMH"
    const sampleSize = Math.min(5, jsonData.length - dataStartRow)
    let foundAMH = false
    
    for (let i = 0; i < sampleSize; i++) {
      const rowIndex = dataStartRow + i
      if (rowIndex < jsonData.length) {
        const row = jsonData[rowIndex] as string[]
        if (row && row.length > 0) {
          // Read COMPANYCODE value using detected index
          const rawCompanyCode = row[companyCodeColIndex]
          const companyCode = rawCompanyCode == null ? '' : String(rawCompanyCode).trim()
          if (companyCode.toUpperCase() === 'AMH') {
            foundAMH = true
            break
          }
        }
      }
    }
    
    if (!foundAMH) {
      return { isValid: false, error: 'You uploaded the wrong company\'s policy report to the AHL section - COMPANYCODE does not contain AMH values' }
    }
    
    return { isValid: true }
  } catch (error) {
    return { isValid: false, error: `Error verifying AHL data: ${error instanceof Error ? error.message : 'Unknown error'}` }
  }
}

/**
 * AHL: Processes payment mode display text - converts M to Monthly, Q to Quarterly, etc.
 * 
 * @param paymentMode - Payment mode from AHL Excel (M, Q, etc.)
 * @returns string | null - Standardized payment frequency
 */
function processAHLPaymentMode(paymentMode: any): string | null {
  if (paymentMode == null) return null
  const modeStr = String(paymentMode)
  if (modeStr.trim() === '') return null
  
  const mode = modeStr.trim().toUpperCase()
  
  switch (mode) {
    case 'M':
      return 'Monthly'
    case 'Q':
      return 'Quarterly'
    case 'S':
      return 'Semi-Annual'
    case 'A':
      return 'Annual'
    default:
      return modeStr.trim()
  }
}

/**
 * AHL: Processes payment method display text - converts "DIRECT BILL" to "Direct Bill"
 * 
 * @param paymentMethod - Payment method from AHL Excel
 * @returns string | null - Properly formatted payment method
 */
function processAHLPaymentMethod(paymentMethod: any): string | null {
  if (paymentMethod == null) return null
  const methodStr = String(paymentMethod)
  if (methodStr.trim() === '') return null
  
  const method = methodStr.trim()
  
  // Handle "DIRECT BILL" -> "Direct Bill"
  if (method.toUpperCase() === 'DIRECT BILL') {
    return 'Direct Bill'
  }
  
  // Capitalize first letter of each word
  return method.toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * AHL: Processes monetary values - removes dollar signs and commas, converts to number
 * 
 * @param value - Monetary value string (e.g., "$1,234.56")
 * @returns number | null - Converted number
 */
function processAHLMonetaryValue(value: any): number | null {
  if (value == null) return null
  if (typeof value === 'number') {
    return isNaN(value) ? null : value
  }
  const str = String(value).trim()
  if (str === '') return null

  // Remove dollar signs, commas, whitespace and convert to number
  const cleanedValue = str.replace(/[$,\s]/g, '')
  const num = parseFloat(cleanedValue)
  return isNaN(num) ? null : num
}

/**
 * AHL: Processes address components - capitalizes first letter of each word
 * 
 * @param addressComponent - Address component (ADDRESSLINE1, ADDRESSLINE2, etc.)
 * @returns string | null - Properly capitalized address component
 */
function processAHLAddressComponent(addressComponent: any): string | null {
  if (addressComponent == null) return null
  const addrStr = String(addressComponent)
  if (addrStr.trim() === '') return null
  
  return addrStr.trim()
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * AHL: Builds complete client address from address components
 * 
 * @param addressLine1 - First address line
 * @param addressLine2 - Second address line
 * @param addressLine3 - Third address line
 * @param city - City
 * @param state - State
 * @param postalCode - Postal code
 * @returns string | null - Complete formatted address
 */
function buildAHLClientAddress(
  addressLine1: string,
  addressLine2: string,
  addressLine3: string,
  city: string,
  state: string,
  postalCode: string
): string | null {
  const addressParts = []
  
  // Process each address component
  const processedLine1 = processAHLAddressComponent(addressLine1)
  const processedLine2 = processAHLAddressComponent(addressLine2)
  const processedLine3 = processAHLAddressComponent(addressLine3)
  const processedCity = processAHLAddressComponent(city)
  const processedState = processAHLAddressComponent(state)
  const processedPostalCode = postalCode ? postalCode.trim() : ''
  
  // Build address parts
  if (processedLine1) addressParts.push(processedLine1)
  if (processedLine2) addressParts.push(processedLine2)
  if (processedLine3) addressParts.push(processedLine3)
  
  if (addressParts.length === 0) return null
  
  // Add city, state, postal code
  const locationParts = []
  if (processedCity) locationParts.push(processedCity)
  if (processedState) locationParts.push(processedState)
  if (processedPostalCode) locationParts.push(processedPostalCode)
  
  const locationString = locationParts.join(', ')
  return `${addressParts.join(' ')}, ${locationString}`
}

/**
 * AHL: Processes phone number - removes spaces, parentheses, and other non-numeric characters
 * 
 * @param phone - Phone number string
 * @returns string | null - Cleaned phone number with only digits
 */
function processAHLPhoneNumber(phone: any): string | null {
  if (phone == null) return null
  const phoneStr = String(phone)
  if (phoneStr.trim() === '') return null
  
  // Remove all non-numeric characters (spaces, parentheses, dashes, etc.)
  const cleanedPhone = phoneStr.replace(/\D/g, '')
  
  // Return null if no digits found
  return cleanedPhone.length > 0 ? cleanedPhone : null
}

/**
 * AHL: Validates and converts date string to proper format
 * Dates should already be in YYYY-MM-DD format but validates and converts if needed
 * 
 * @param dateString - Date string from AHL Excel
 * @returns string | null - Validated date in YYYY-MM-DD format or null if invalid
 */
function validateAHLDate(dateInput: any): string | null {
  if (dateInput == null) return null

  // Excel serial date (number)
  if (typeof dateInput === 'number') {
    const base = new Date(Date.UTC(1899, 11, 30))
    base.setUTCDate(base.getUTCDate() + Math.floor(dateInput))
    const year = base.getUTCFullYear()
    const month = String(base.getUTCMonth() + 1).padStart(2, '0')
    const day = String(base.getUTCDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  // JavaScript Date
  if (dateInput instanceof Date && !isNaN(dateInput.getTime())) {
    const year = dateInput.getFullYear()
    const month = String(dateInput.getMonth() + 1).padStart(2, '0')
    const day = String(dateInput.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  const trimmedDate = String(dateInput).trim()
  if (trimmedDate === '') return null

  // Already in YYYY-MM-DD
  if (/^\d{4}-\d{2}-\d{2}$/.test(trimmedDate)) {
    const d = new Date(trimmedDate)
    return isNaN(d.getTime()) ? null : trimmedDate
  }

  // Parse other formats
  const parsed = new Date(trimmedDate)
  if (!isNaN(parsed.getTime())) {
    const year = parsed.getFullYear()
    const month = String(parsed.getMonth() + 1).padStart(2, '0')
    const day = String(parsed.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  return null
}

/**
 * AHL: Parses American Home Life Excel content and converts it to PolicyReportStaging objects
 * 
 * @param excelBuffer - The Excel file buffer
 * @param carrierName - The carrier name
 * @param agencyId - The agency ID
 * @returns Promise<PolicyReportStaging[]> - Array of parsed policy reports
 */
async function parseAHLExcelToPolicyReports(
  excelBuffer: Buffer, 
  carrierName: string, 
  agencyId: string
): Promise<PolicyReportStaging[]> {
  try {
    // Parse Excel file
    const workbook = XLSX.read(excelBuffer, { type: 'buffer' })
    
    // Validate Excel structure
    const validation = validateAHLExcelStructure(workbook)
    if (!validation.isValid) {
      throw new Error(validation.error)
    }
    
    // Verify AHL data
    const dataVerification = verifyAHLData(workbook, validation.dataStartRow!)
    if (!dataVerification.isValid) {
      throw new Error(dataVerification.error)
    }
    
    // Get worksheet and convert to JSON
    const sheetName = workbook.SheetNames[0]
    const worksheet = workbook.Sheets[sheetName]
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    if (jsonData.length <= validation.dataStartRow!) {
      throw new Error('No data found in Excel file')
    }
    
    // Get headers from the header row
    const headers = jsonData[validation.dataStartRow! - 1] as string[]
    
    // Map AHL records to PolicyReportStaging objects
    const policyReports: PolicyReportStaging[] = []
    
    for (let i = validation.dataStartRow!; i < jsonData.length; i++) {
      const row = jsonData[i] as string[]
      
      try {
        // Create record object from headers and row data
        const record: any = {}
        headers.forEach((header, index) => {
          record[header] = row[index] || ''
        })
        
        // Check for required fields
        const requiredFields = ['INSUREDNAME', 'POLICYNUMBER', 'AGENTNUMBER', 'AGENTCOMPLETENAME', 'STATUSCATEGORY', 'ORIGEFFDATE']
        const missingFields = requiredFields.filter(field => !record[field] || record[field].toString().trim() === '')
        
        if (missingFields.length > 0) {
          console.log(`Row ${i + 1} missing required fields: ${missingFields.join(', ')}`, record)
          continue // Skip this row but continue processing others
        }
        
        // Process dates
        const policyEffectiveDate = validateAHLDate(record.ORIGEFFDATE)
        const birthDate = validateAHLDate(record.BIRTHDATE)
        
        // Process monetary values
        const faceValue = processAHLMonetaryValue(record.FACEVALUE)
        const issuedPremium = processAHLMonetaryValue(record.ISSUEDPREMIUM)
        const currentAnnualPremium = processAHLMonetaryValue(record.CURRENTANNUALPREMIUM)
        const currentModalPremium = processAHLMonetaryValue(record.CURRENTMODALPREMIUM)
        
        // Process payment information
        const paymentFrequency = processAHLPaymentMode(record.PAYMENTMODEDISPLAYTEXT)
        const paymentMethod = processAHLPaymentMethod(record.PAYMENTMETHODDISPLAYTEXT)
        
        // Process address components
        const clientAddress = buildAHLClientAddress(
          record.ADDRESSLINE1,
          record.ADDRESSLINE2,
          record.ADDRESSLINE3,
          record.CITY,
          record.STATE,
          record.POSTALCODE
        )
        
        // Process phone and email
        const clientPhone = processAHLPhoneNumber(record.PHONE1)
        const clientEmail = record.EMAIL && record.EMAIL.trim() !== '' ? record.EMAIL.trim().toLowerCase() : null
        
        // Process issue age
        const issueAge = toNumber(record.ISSUEAGE)
        
        const policyReport: PolicyReportStaging = {
          client_name: cleanValue(record.INSUREDNAME),
          policy_number: cleanValue(cleanCSVValue(record.POLICYNUMBER)),
          writing_agent_number: cleanValue(cleanCSVValue(record.AGENTNUMBER)),
          agent_name: cleanValue(record.AGENTCOMPLETENAME),
          status: cleanValue(record.STATUSCATEGORY),
          policy_effective_date: policyEffectiveDate ? cleanValue(policyEffectiveDate) : null,
          product: cleanValue(record.LONGDESCRIPTION),
          date_of_birth: birthDate ? cleanValue(birthDate) : null,
          issue_age: issueAge,
          face_value: faceValue,
          payment_method: paymentMethod ? cleanValue(paymentMethod) : null,
          payment_frequency: paymentFrequency ? cleanValue(paymentFrequency) : null,
          payment_cycle_premium: currentModalPremium,
          client_address: clientAddress ? cleanValue(clientAddress) : null,
          client_phone: clientPhone ? cleanValue(clientPhone) : null,
          client_email: clientEmail ? cleanValue(clientEmail) : null,
          state: cleanValue(record.STATE),
          zipcode: cleanValue(record.POSTALCODE),
          annual_premium: currentAnnualPremium,
          client_gender: cleanValue(record.SEX),
          agency_id: agencyId,
          carrier_name: 'American Home Life Insurance Company'
        }
        
        policyReports.push(policyReport)
      } catch (rowError) {
        console.error(`Error processing row ${i + 1}:`, rowError, row)
        // Continue processing other rows
      }
    }
    
    return policyReports
  } catch (error) {
    console.error('AHL Excel parsing error:', error)
    throw new Error(`Failed to parse AHL Excel: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

// ============================================================================
// AFLAC SPECIFIC FUNCTIONS
// ============================================================================

/**
 * Aflac: Validates Aflac Excel file structure and checks for required columns
 * Verifies that it is an Excel file, contains data, and is an Aflac Excel file by checking COMPANYCODE column
 * 
 * @param workbook - The Excel workbook object
 * @returns {isValid: boolean, error?: string, dataStartRow?: number}
 */
function validateAflacExcelStructure(workbook: XLSX.WorkBook): {isValid: boolean, error?: string, dataStartRow?: number} {
  try {
    // Get the first worksheet
    const sheetName = workbook.SheetNames[0]
    if (!sheetName) {
      return { isValid: false, error: 'No worksheets found in Excel file' }
    }
    
    const worksheet = workbook.Sheets[sheetName]
    if (!worksheet) {
      return { isValid: false, error: 'Unable to read worksheet' }
    }
    
    // Convert worksheet to JSON to find the data
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    if (!jsonData || jsonData.length === 0) {
      return { isValid: false, error: 'Excel file contains no data' }
    }
    
    // Find the row that contains the column headers
    let headerRowIndex = -1
    let headers: string[] = []
    
    for (let i = 0; i < jsonData.length; i++) {
      const row = jsonData[i] as string[]
      if (row && row.length > 0) {
        // Look for COMPANYCODE column to identify header row
        const companyCodeIndex = row.findIndex(cell => 
          cell && cell.toString().toUpperCase().includes('COMPANYCODE')
        )
        
        if (companyCodeIndex !== -1) {
          headerRowIndex = i
          headers = row.map(cell => cell ? cell.toString().trim() : '')
          break
        }
      }
    }
    
    if (headerRowIndex === -1) {
      return { isValid: false, error: 'Failed to parse policy report, missing COMPANYCODE column - this does not appear to be an Aflac Excel file' }
    }
    
    // Required columns for Aflac policy reports
    const requiredColumns = [
      'COMPANYCODE', 'POLICYNUMBER', 'STATUSCATEGORY', 'STATUSDISPLAYTEXT',
      'PRODUCT', 'APP TYPE', 'APPRECDDATE', 'APPSIGNATUREDATE', 'ORIGEFFDATE',
      'PAIDTODATE', 'ISSUEDATE', 'TERMDATE', 'ISSUEDPREMIUM',
      'CURRENTANNUALPREMIUM', 'CURRENTMODALPREMIUM', 'DRAFTDAY',
      'PAYMENTMODEDISPLAYTEXT', 'PAYMENTMETHODDISPLAYTEXT', 'LASTPAYMENTDATE',
      'LASTPAYAMT', 'ISSUEZIP', 'REPLACEMENTIND', 'REPLCOMPANYCODE',
      'REPLPOLICYNUMBER', 'FACEVALUE', 'ISSUESTATE', 'HOUSEHOLD DISCOUNT %',
      'MULTIPLE POLICY DISCOUNT %', 'LONGDESCRIPTION', 'INSUREDNAME',
      'SUFFIXTITLE', 'SEX', 'BIRTHDATE', 'ADDRESSLINE1', 'ADDRESSLINE2',
      'ADDRESSLINE3', 'CITY', 'STATE', 'POSTALCODE', 'PHONE1', 'EMAIL',
      'ISSUEAGE', 'AGENTNUMBER', 'AGENTCOMPLETENAME', 'SPLITLEVEL',
      'SPLIT %'
    ]
    
    const missingColumns = requiredColumns.filter(col => 
      !headers.some(header => header.toUpperCase() === col.toUpperCase())
    )
    
    if (missingColumns.length > 0) {
      return { 
        isValid: false, 
        error: `Failed to parse policy report, missing columns: ${missingColumns.join(', ')}` 
      }
    }
    
    return { isValid: true, dataStartRow: headerRowIndex + 1 }
  } catch (error) {
    return { isValid: false, error: `Error validating Aflac Excel structure: ${error instanceof Error ? error.message : 'Unknown error'}` }
  }
}

/**
 * Aflac: Verifies that the Excel file contains Aflac data by checking COMPANYCODE values
 * 
 * @param workbook - The Excel workbook object
 * @param dataStartRow - The row where data starts (after headers)
 * @returns {isValid: boolean, error?: string}
 */
function verifyAflacData(workbook: XLSX.WorkBook, dataStartRow: number): {isValid: boolean, error?: string} {
  try {
    const sheetName = workbook.SheetNames[0]
    const worksheet = workbook.Sheets[sheetName]
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    // Determine header row and COMPANYCODE column index
    const headerRowIndex = dataStartRow - 1
    const headerRow = jsonData[headerRowIndex] as string[]
    if (!headerRow) {
      return { isValid: false, error: 'Unable to locate header row for Aflac Excel' }
    }
    const companyCodeColIndex = headerRow.findIndex(h => String(h).toUpperCase().trim() === 'COMPANYCODE')
    if (companyCodeColIndex === -1) {
      return { isValid: false, error: 'COMPANYCODE column not found in Aflac Excel headers' }
    }

    // Check a few random rows to verify COMPANYCODE contains "TIER"
    const sampleSize = Math.min(5, jsonData.length - dataStartRow)
    let foundTIER = false
    
    for (let i = 0; i < sampleSize; i++) {
      const rowIndex = dataStartRow + i
      if (rowIndex < jsonData.length) {
        const row = jsonData[rowIndex] as string[]
        if (row && row.length > 0) {
          // Read COMPANYCODE value using detected index
          const rawCompanyCode = row[companyCodeColIndex]
          const companyCode = rawCompanyCode == null ? '' : String(rawCompanyCode).trim()
          if (companyCode.toUpperCase() === 'TIER') {
            foundTIER = true
            break
          }
        }
      }
    }
    
    if (!foundTIER) {
      return { isValid: false, error: 'You uploaded the wrong company\'s policy report to the Aflac section - COMPANYCODE does not contain TIER values' }
    }
    
    return { isValid: true }
  } catch (error) {
    return { isValid: false, error: `Error verifying Aflac data: ${error instanceof Error ? error.message : 'Unknown error'}` }
  }
}

/**
 * Aflac: Processes payment mode display text - converts M to Monthly, Q to Quarterly, etc.
 * 
 * @param paymentMode - Payment mode from Aflac Excel (M, Q, etc.)
 * @returns string | null - Standardized payment frequency
 */
function processAflacPaymentMode(paymentMode: any): string | null {
  if (paymentMode == null) return null
  const modeStr = String(paymentMode)
  if (modeStr.trim() === '') return null
  
  const mode = modeStr.trim().toUpperCase()
  
  switch (mode) {
    case 'M':
      return 'Monthly'
    case 'Q':
      return 'Quarterly'
    case 'S':
      return 'Semi-Annual'
    case 'A':
      return 'Annual'
    default:
      return modeStr.trim()
  }
}

/**
 * Aflac: Processes payment method display text - converts "DIRECT BILL" to "Direct Bill"
 * 
 * @param paymentMethod - Payment method from Aflac Excel
 * @returns string | null - Properly formatted payment method
 */
function processAflacPaymentMethod(paymentMethod: any): string | null {
  if (paymentMethod == null) return null
  const methodStr = String(paymentMethod)
  if (methodStr.trim() === '') return null
  
  const method = methodStr.trim()
  
  // Handle "DIRECT BILL" -> "Direct Bill"
  if (method.toUpperCase() === 'DIRECT BILL') {
    return 'Direct Bill'
  }
  
  // Capitalize first letter of each word
  return method.toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * Aflac: Processes monetary values - removes dollar signs and commas, converts to number
 * 
 * @param value - Monetary value string (e.g., "$1,234.56")
 * @returns number | null - Converted number
 */
function processAflacMonetaryValue(value: any): number | null {
  if (value == null) return null
  if (typeof value === 'number') {
    return isNaN(value) ? null : value
  }
  const str = String(value).trim()
  if (str === '') return null

  // Remove dollar signs, commas, whitespace and convert to number
  const cleanedValue = str.replace(/[$,\s]/g, '')
  const num = parseFloat(cleanedValue)
  return isNaN(num) ? null : num
}

/**
 * Aflac: Processes address components - capitalizes first letter of each word
 * 
 * @param addressComponent - Address component (ADDRESSLINE1, ADDRESSLINE2, etc.)
 * @returns string | null - Properly capitalized address component
 */
function processAflacAddressComponent(addressComponent: any): string | null {
  if (addressComponent == null) return null
  const addrStr = String(addressComponent)
  if (addrStr.trim() === '') return null
  
  return addrStr.trim()
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * Aflac: Builds complete client address from address components
 * 
 * @param addressLine1 - First address line
 * @param addressLine2 - Second address line
 * @param addressLine3 - Third address line
 * @param city - City
 * @param state - State
 * @param postalCode - Postal code
 * @returns string | null - Complete formatted address
 */
function buildAflacClientAddress(
  addressLine1: string,
  addressLine2: string,
  addressLine3: string,
  city: string,
  state: string,
  postalCode: string
): string | null {
  const addressParts = []
  
  // Process each address component
  const processedLine1 = processAflacAddressComponent(addressLine1)
  const processedLine2 = processAflacAddressComponent(addressLine2)
  const processedLine3 = processAflacAddressComponent(addressLine3)
  const processedCity = processAflacAddressComponent(city)
  const processedState = processAflacAddressComponent(state)
  const processedPostalCode = postalCode ? postalCode.trim() : ''
  
  // Build address parts
  if (processedLine1) addressParts.push(processedLine1)
  if (processedLine2) addressParts.push(processedLine2)
  if (processedLine3) addressParts.push(processedLine3)
  
  if (addressParts.length === 0) return null
  
  // Add city, state, postal code
  const locationParts = []
  if (processedCity) locationParts.push(processedCity)
  if (processedState) locationParts.push(processedState)
  if (processedPostalCode) locationParts.push(processedPostalCode)
  
  const locationString = locationParts.join(', ')
  return `${addressParts.join(' ')}, ${locationString}`
}

/**
 * Aflac: Processes phone number - removes spaces, parentheses, and other non-numeric characters
 * 
 * @param phone - Phone number string
 * @returns string | null - Cleaned phone number with only digits
 */
function processAflacPhoneNumber(phone: any): string | null {
  if (phone == null) return null
  const phoneStr = String(phone)
  if (phoneStr.trim() === '') return null
  
  // Remove all non-numeric characters (spaces, parentheses, dashes, etc.)
  const cleanedPhone = phoneStr.replace(/\D/g, '')
  
  // Return null if no digits found
  return cleanedPhone.length > 0 ? cleanedPhone : null
}

/**
 * Aflac: Validates and converts date string to proper format
 * Dates should already be in YYYY-MM-DD format but validates and converts if needed
 * 
 * @param dateString - Date string from Aflac Excel
 * @returns string | null - Validated date in YYYY-MM-DD format or null if invalid
 */
function validateAflacDate(dateInput: any): string | null {
  if (dateInput == null) return null

  // Excel serial date (number)
  if (typeof dateInput === 'number') {
    const base = new Date(Date.UTC(1899, 11, 30))
    base.setUTCDate(base.getUTCDate() + Math.floor(dateInput))
    const year = base.getUTCFullYear()
    const month = String(base.getUTCMonth() + 1).padStart(2, '0')
    const day = String(base.getUTCDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  // JavaScript Date
  if (dateInput instanceof Date && !isNaN(dateInput.getTime())) {
    const year = dateInput.getFullYear()
    const month = String(dateInput.getMonth() + 1).padStart(2, '0')
    const day = String(dateInput.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  const trimmedDate = String(dateInput).trim()
  if (trimmedDate === '') return null

  // Already in YYYY-MM-DD
  if (/^\d{4}-\d{2}-\d{2}$/.test(trimmedDate)) {
    const d = new Date(trimmedDate)
    return isNaN(d.getTime()) ? null : trimmedDate
  }

  // Parse other formats
  const parsed = new Date(trimmedDate)
  if (!isNaN(parsed.getTime())) {
    const year = parsed.getFullYear()
    const month = String(parsed.getMonth() + 1).padStart(2, '0')
    const day = String(parsed.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  return null
}

/**
 * Aflac: Parses Aflac Excel content and converts it to PolicyReportStaging objects
 * 
 * @param excelBuffer - The Excel file buffer
 * @param carrierName - The carrier name
 * @param agencyId - The agency ID
 * @returns Promise<PolicyReportStaging[]> - Array of parsed policy reports
 */
async function parseAflacExcelToPolicyReports(
  excelBuffer: Buffer, 
  carrierName: string, 
  agencyId: string
): Promise<PolicyReportStaging[]> {
  try {
    // Parse Excel file
    const workbook = XLSX.read(excelBuffer, { type: 'buffer' })
    
    // Validate Excel structure
    const validation = validateAflacExcelStructure(workbook)
    if (!validation.isValid) {
      throw new Error(validation.error)
    }
    
    // Verify Aflac data
    const dataVerification = verifyAflacData(workbook, validation.dataStartRow!)
    if (!dataVerification.isValid) {
      throw new Error(dataVerification.error)
    }
    
    // Get worksheet and convert to JSON
    const sheetName = workbook.SheetNames[0]
    const worksheet = workbook.Sheets[sheetName]
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    if (jsonData.length <= validation.dataStartRow!) {
      throw new Error('No data found in Excel file')
    }
    
    // Get headers from the header row
    const headers = jsonData[validation.dataStartRow! - 1] as string[]
    
    // Map Aflac records to PolicyReportStaging objects
    const policyReports: PolicyReportStaging[] = []
    
    for (let i = validation.dataStartRow!; i < jsonData.length; i++) {
      const row = jsonData[i] as string[]
      
      try {
        // Create record object from headers and row data
        const record: any = {}
        headers.forEach((header, index) => {
          record[header] = row[index] || ''
        })
        
        // Check for required fields
        const requiredFields = ['INSUREDNAME', 'POLICYNUMBER', 'AGENTNUMBER', 'AGENTCOMPLETENAME', 'STATUSCATEGORY', 'ORIGEFFDATE']
        const missingFields = requiredFields.filter(field => !record[field] || record[field].toString().trim() === '')
        
        if (missingFields.length > 0) {
          console.log(`Row ${i + 1} missing required fields: ${missingFields.join(', ')}`, record)
          continue // Skip this row but continue processing others
        }
        
        // Process dates
        const policyEffectiveDate = validateAflacDate(record.ORIGEFFDATE)
        const birthDate = validateAflacDate(record.BIRTHDATE)
        
        // Process monetary values
        const faceValue = processAflacMonetaryValue(record.FACEVALUE)
        const issuedPremium = processAflacMonetaryValue(record.ISSUEDPREMIUM)
        const currentAnnualPremium = processAflacMonetaryValue(record.CURRENTANNUALPREMIUM)
        const currentModalPremium = processAflacMonetaryValue(record.CURRENTMODALPREMIUM)
        
        // Process payment information
        const paymentFrequency = processAflacPaymentMode(record.PAYMENTMODEDISPLAYTEXT)
        const paymentMethod = processAflacPaymentMethod(record.PAYMENTMETHODDISPLAYTEXT)
        
        // Process address components
        const clientAddress = buildAflacClientAddress(
          record.ADDRESSLINE1,
          record.ADDRESSLINE2,
          record.ADDRESSLINE3,
          record.CITY,
          record.STATE,
          record.POSTALCODE
        )
        
        // Process phone and email
        const clientPhone = processAflacPhoneNumber(record.PHONE1)
        const clientEmail = record.EMAIL && record.EMAIL.trim() !== '' ? record.EMAIL.trim().toLowerCase() : null
        
        // Process issue age
        const issueAge = toNumber(record.ISSUEAGE)
        
        const policyReport: PolicyReportStaging = {
          client_name: cleanValue(record.INSUREDNAME),
          policy_number: cleanValue(cleanCSVValue(record.POLICYNUMBER)),
          writing_agent_number: cleanValue(cleanCSVValue(record.AGENTNUMBER)),
          agent_name: cleanValue(record.AGENTCOMPLETENAME),
          status: cleanValue(record.STATUSCATEGORY),
          policy_effective_date: policyEffectiveDate ? cleanValue(policyEffectiveDate) : null,
          product: cleanValue(record.LONGDESCRIPTION),
          date_of_birth: birthDate ? cleanValue(birthDate) : null,
          issue_age: issueAge,
          face_value: faceValue,
          payment_method: paymentMethod ? cleanValue(paymentMethod) : null,
          payment_frequency: paymentFrequency ? cleanValue(paymentFrequency) : null,
          payment_cycle_premium: currentModalPremium,
          client_address: clientAddress ? cleanValue(clientAddress) : null,
          client_phone: clientPhone ? cleanValue(clientPhone) : null,
          client_email: clientEmail ? cleanValue(clientEmail) : null,
          state: cleanValue(record.STATE),
          zipcode: cleanValue(record.POSTALCODE),
          annual_premium: currentAnnualPremium,
          client_gender: cleanValue(record.SEX),
          agency_id: agencyId,
          carrier_name: 'Aflac'
        }
        
        policyReports.push(policyReport)
      } catch (rowError) {
        console.error(`Error processing row ${i + 1}:`, rowError, row)
        // Continue processing other rows
      }
    }
    
    return policyReports
  } catch (error) {
    console.error('Aflac Excel parsing error:', error)
    throw new Error(`Failed to parse Aflac Excel: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

// ============================================================================
// AETNA SPECIFIC FUNCTIONS
// ============================================================================

/**
 * Aetna: Validates Aetna Excel file structure and checks for required columns
 * Verifies that it is an Excel file, contains data, and is an Aetna Excel file by checking COMPANYCODE column
 * 
 * @param workbook - The Excel workbook object
 * @returns {isValid: boolean, error?: string, dataStartRow?: number}
 */
function validateAetnaExcelStructure(workbook: XLSX.WorkBook): {isValid: boolean, error?: string, dataStartRow?: number} {
  try {
    // Get the first worksheet
    const sheetName = workbook.SheetNames[0]
    if (!sheetName) {
      return { isValid: false, error: 'No worksheets found in Excel file' }
    }
    
    const worksheet = workbook.Sheets[sheetName]
    if (!worksheet) {
      return { isValid: false, error: 'Unable to read worksheet' }
    }
    
    // Convert worksheet to JSON to find the data
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    if (!jsonData || jsonData.length === 0) {
      return { isValid: false, error: 'Excel file contains no data' }
    }
    
    // Find the row that contains the column headers
    let headerRowIndex = -1
    let headers: string[] = []
    
    for (let i = 0; i < jsonData.length; i++) {
      const row = jsonData[i] as string[]
      if (row && row.length > 0) {
        // Look for COMPANYCODE column to identify header row
        const companyCodeIndex = row.findIndex(cell => 
          cell && cell.toString().toUpperCase().includes('COMPANYCODE')
        )
        
        if (companyCodeIndex !== -1) {
          headerRowIndex = i
          headers = row.map(cell => cell ? cell.toString().trim() : '')
          break
        }
      }
    }
    
    if (headerRowIndex === -1) {
      return { isValid: false, error: 'Failed to parse policy report, missing COMPANYCODE column - this does not appear to be an Aetna Excel file' }
    }
    
    // Required columns for Aetna policy reports
    const requiredColumns = [
      'COMPANYCODE', 'POLICYNUMBER', 'STATUSCATEGORY', 'STATUSDISPLAYTEXT',
      'PRODUCT', 'APP TYPE', 'APPRECDDATE', 'APPSIGNATUREDATE', 'ORIGEFFDATE',
      'PAIDTODATE', 'ISSUEDATE', 'TERMDATE', 'ISSUEDPREMIUM',
      'CURRENTANNUALPREMIUM', 'CURRENTMODALPREMIUM', 'DRAFTDAY',
      'PAYMENTMODEDISPLAYTEXT', 'PAYMENTMETHODDISPLAYTEXT', 'LASTPAYMENTDATE',
      'LASTPAYAMT', 'ISSUEZIP', 'REPLACEMENTIND', 'REPLCOMPANYCODE',
      'REPLPOLICYNUMBER', 'FACEVALUE', 'ISSUESTATE', 'HOUSEHOLD DISCOUNT %',
      'MULTIPLE POLICY DISCOUNT %', 'LONGDESCRIPTION', 'INSUREDNAME',
      'SUFFIXTITLE', 'SEX', 'BIRTHDATE', 'ADDRESSLINE1', 'ADDRESSLINE2',
      'ADDRESSLINE3', 'CITY', 'STATE', 'POSTALCODE', 'PHONE1', 'EMAIL',
      'ISSUEAGE', 'AGENTNUMBER', 'AGENTCOMPLETENAME', 'SPLITLEVEL',
      'SPLIT %'
    ]
    
    const missingColumns = requiredColumns.filter(col => 
      !headers.some(header => header.toUpperCase() === col.toUpperCase())
    )
    
    if (missingColumns.length > 0) {
      return { 
        isValid: false, 
        error: `Failed to parse policy report, missing columns: ${missingColumns.join(', ')}` 
      }
    }
    
    return { isValid: true, dataStartRow: headerRowIndex + 1 }
  } catch (error) {
    return { isValid: false, error: `Error validating Aetna Excel structure: ${error instanceof Error ? error.message : 'Unknown error'}` }
  }
}

/**
 * Aetna: Verifies that the Excel file contains Aetna data by checking COMPANYCODE values
 * 
 * @param workbook - The Excel workbook object
 * @param dataStartRow - The row where data starts (after headers)
 * @returns {isValid: boolean, error?: string}
 */
function verifyAetnaData(workbook: XLSX.WorkBook, dataStartRow: number): {isValid: boolean, error?: string} {
  try {
    const sheetName = workbook.SheetNames[0]
    const worksheet = workbook.Sheets[sheetName]
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    // Determine header row and COMPANYCODE column index
    const headerRowIndex = dataStartRow - 1
    const headerRow = jsonData[headerRowIndex] as string[]
    if (!headerRow) {
      return { isValid: false, error: 'Unable to locate header row for Aetna Excel' }
    }
    const companyCodeColIndex = headerRow.findIndex(h => String(h).toUpperCase().trim() === 'COMPANYCODE')
    if (companyCodeColIndex === -1) {
      return { isValid: false, error: 'COMPANYCODE column not found in Aetna Excel headers' }
    }

    // Check a few random rows to verify COMPANYCODE contains "ACC"
    const sampleSize = Math.min(5, jsonData.length - dataStartRow)
    let foundACC = false
    
    for (let i = 0; i < sampleSize; i++) {
      const rowIndex = dataStartRow + i
      if (rowIndex < jsonData.length) {
        const row = jsonData[rowIndex] as string[]
        if (row && row.length > 0) {
          // Read COMPANYCODE value using detected index
          const rawCompanyCode = row[companyCodeColIndex]
          const companyCode = rawCompanyCode == null ? '' : String(rawCompanyCode).trim()
          if (companyCode.toUpperCase() === 'ACC') {
            foundACC = true
            break
          }
        }
      }
    }
    
    if (!foundACC) {
      return { isValid: false, error: 'You uploaded the wrong company\'s policy report to the Aetna section - COMPANYCODE does not contain ACC values' }
    }
    
    return { isValid: true }
  } catch (error) {
    return { isValid: false, error: `Error verifying Aetna data: ${error instanceof Error ? error.message : 'Unknown error'}` }
  }
}

/**
 * Aetna: Processes payment mode display text - converts M to Monthly, Q to Quarterly, etc.
 * 
 * @param paymentMode - Payment mode from Aetna Excel (M, Q, etc.)
 * @returns string | null - Standardized payment frequency
 */
function processAetnaPaymentMode(paymentMode: any): string | null {
  if (paymentMode == null) return null
  const modeStr = String(paymentMode)
  if (modeStr.trim() === '') return null
  
  const mode = modeStr.trim().toUpperCase()
  
  switch (mode) {
    case 'M':
      return 'Monthly'
    case 'Q':
      return 'Quarterly'
    case 'S':
      return 'Semi-Annual'
    case 'A':
      return 'Annual'
    default:
      return modeStr.trim()
  }
}

/**
 * Aetna: Processes payment method display text - converts "DIRECT BILL" to "Direct Bill"
 * 
 * @param paymentMethod - Payment method from Aetna Excel
 * @returns string | null - Properly formatted payment method
 */
function processAetnaPaymentMethod(paymentMethod: any): string | null {
  if (paymentMethod == null) return null
  const methodStr = String(paymentMethod)
  if (methodStr.trim() === '') return null
  
  const method = methodStr.trim()
  
  // Handle "DIRECT BILL" -> "Direct Bill"
  if (method.toUpperCase() === 'DIRECT BILL') {
    return 'Direct Bill'
  }
  
  // Capitalize first letter of each word
  return method.toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * Aetna: Processes monetary values - removes dollar signs and commas, converts to number
 * 
 * @param value - Monetary value string (e.g., "$1,234.56")
 * @returns number | null - Converted number
 */
function processAetnaMonetaryValue(value: any): number | null {
  if (value == null) return null
  if (typeof value === 'number') {
    return isNaN(value) ? null : value
  }
  const str = String(value).trim()
  if (str === '') return null

  // Remove dollar signs, commas, whitespace and convert to number
  const cleanedValue = str.replace(/[$,\s]/g, '')
  const num = parseFloat(cleanedValue)
  return isNaN(num) ? null : num
}

/**
 * Aetna: Processes address components - capitalizes first letter of each word
 * 
 * @param addressComponent - Address component (ADDRESSLINE1, ADDRESSLINE2, etc.)
 * @returns string | null - Properly capitalized address component
 */
function processAetnaAddressComponent(addressComponent: any): string | null {
  if (addressComponent == null) return null
  const addrStr = String(addressComponent)
  if (addrStr.trim() === '') return null
  
  return addrStr.trim()
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * Aetna: Builds complete client address from address components
 * 
 * @param addressLine1 - First address line
 * @param addressLine2 - Second address line
 * @param addressLine3 - Third address line
 * @param city - City
 * @param state - State
 * @param postalCode - Postal code
 * @returns string | null - Complete formatted address
 */
function buildAetnaClientAddress(
  addressLine1: string,
  addressLine2: string,
  addressLine3: string,
  city: string,
  state: string,
  postalCode: string
): string | null {
  const addressParts = []
  
  // Process each address component
  const processedLine1 = processAetnaAddressComponent(addressLine1)
  const processedLine2 = processAetnaAddressComponent(addressLine2)
  const processedLine3 = processAetnaAddressComponent(addressLine3)
  const processedCity = processAetnaAddressComponent(city)
  const processedState = processAetnaAddressComponent(state)
  const processedPostalCode = postalCode ? postalCode.trim() : ''
  
  // Build address parts - skip empty address lines
  if (processedLine1) addressParts.push(processedLine1)
  if (processedLine2) addressParts.push(processedLine2)
  if (processedLine3) addressParts.push(processedLine3)
  
  if (addressParts.length === 0) return null
  
  // Add city, state, postal code
  const locationParts = []
  if (processedCity) locationParts.push(processedCity)
  if (processedState) locationParts.push(processedState)
  if (processedPostalCode) locationParts.push(processedPostalCode)
  
  const locationString = locationParts.join(', ')
  return `${addressParts.join(' ')}, ${locationString}`
}

/**
 * Aetna: Processes phone number - removes spaces, parentheses, and other non-numeric characters
 * 
 * @param phone - Phone number string
 * @returns string | null - Cleaned phone number with only digits
 */
function processAetnaPhoneNumber(phone: any): string | null {
  if (phone == null) return null
  const phoneStr = String(phone)
  if (phoneStr.trim() === '') return null
  
  // Remove all non-numeric characters (spaces, parentheses, dashes, etc.)
  const cleanedPhone = phoneStr.replace(/\D/g, '')
  
  // Return null if no digits found
  return cleanedPhone.length > 0 ? cleanedPhone : null
}

/**
 * Aetna: Validates and converts date string to proper format
 * Dates should already be in YYYY-MM-DD format but validates and converts if needed
 * 
 * @param dateString - Date string from Aetna Excel
 * @returns string | null - Validated date in YYYY-MM-DD format or null if invalid
 */
function validateAetnaDate(dateInput: any): string | null {
  if (dateInput == null) return null

  // Excel serial date (number)
  if (typeof dateInput === 'number') {
    const base = new Date(Date.UTC(1899, 11, 30))
    base.setUTCDate(base.getUTCDate() + Math.floor(dateInput))
    const year = base.getUTCFullYear()
    const month = String(base.getUTCMonth() + 1).padStart(2, '0')
    const day = String(base.getUTCDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  // JavaScript Date
  if (dateInput instanceof Date && !isNaN(dateInput.getTime())) {
    const year = dateInput.getFullYear()
    const month = String(dateInput.getMonth() + 1).padStart(2, '0')
    const day = String(dateInput.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  const trimmedDate = String(dateInput).trim()
  if (trimmedDate === '') return null

  // Already in YYYY-MM-DD
  if (/^\d{4}-\d{2}-\d{2}$/.test(trimmedDate)) {
    const d = new Date(trimmedDate)
    return isNaN(d.getTime()) ? null : trimmedDate
  }

  // Parse other formats
  const parsed = new Date(trimmedDate)
  if (!isNaN(parsed.getTime())) {
    const year = parsed.getFullYear()
    const month = String(parsed.getMonth() + 1).padStart(2, '0')
    const day = String(parsed.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }

  return null
}

/**
 * Aetna: Parses Aetna Excel content and converts it to PolicyReportStaging objects
 * 
 * @param excelBuffer - The Excel file buffer
 * @param carrierName - The carrier name
 * @param agencyId - The agency ID
 * @returns Promise<PolicyReportStaging[]> - Array of parsed policy reports
 */
async function parseAetnaExcelToPolicyReports(
  excelBuffer: Buffer, 
  carrierName: string, 
  agencyId: string
): Promise<PolicyReportStaging[]> {
  try {
    // Parse Excel file
    const workbook = XLSX.read(excelBuffer, { type: 'buffer' })
    
    // Validate Excel structure
    const validation = validateAetnaExcelStructure(workbook)
    if (!validation.isValid) {
      throw new Error(validation.error)
    }
    
    // Verify Aetna data
    const dataVerification = verifyAetnaData(workbook, validation.dataStartRow!)
    if (!dataVerification.isValid) {
      throw new Error(dataVerification.error)
    }
    
    // Get worksheet and convert to JSON
    const sheetName = workbook.SheetNames[0]
    const worksheet = workbook.Sheets[sheetName]
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' })
    
    if (jsonData.length <= validation.dataStartRow!) {
      throw new Error('No data found in Excel file')
    }
    
    // Get headers from the header row
    const headers = jsonData[validation.dataStartRow! - 1] as string[]
    
    // Map Aetna records to PolicyReportStaging objects
    const policyReports: PolicyReportStaging[] = []
    
    for (let i = validation.dataStartRow!; i < jsonData.length; i++) {
      const row = jsonData[i] as string[]
      
      try {
        // Create record object from headers and row data
        const record: any = {}
        headers.forEach((header, index) => {
          record[header] = row[index] || ''
        })
        
        // Check for required fields
        const requiredFields = ['INSUREDNAME', 'POLICYNUMBER', 'AGENTNUMBER', 'AGENTCOMPLETENAME', 'STATUSCATEGORY', 'ORIGEFFDATE']
        const missingFields = requiredFields.filter(field => !record[field] || record[field].toString().trim() === '')
        
        if (missingFields.length > 0) {
          console.log(`Row ${i + 1} missing required fields: ${missingFields.join(', ')}`, record)
          continue // Skip this row but continue processing others
        }
        
        // Process dates
        const policyEffectiveDate = validateAetnaDate(record.ORIGEFFDATE)
        const birthDate = validateAetnaDate(record.BIRTHDATE)
        
        // Process monetary values
        const faceValue = processAetnaMonetaryValue(record.FACEVALUE)
        const issuedPremium = processAetnaMonetaryValue(record.ISSUEDPREMIUM)
        const currentAnnualPremium = processAetnaMonetaryValue(record.CURRENTANNUALPREMIUM)
        const currentModalPremium = processAetnaMonetaryValue(record.CURRENTMODALPREMIUM)
        
        // Process payment information
        const paymentFrequency = processAetnaPaymentMode(record.PAYMENTMODEDISPLAYTEXT)
        const paymentMethod = processAetnaPaymentMethod(record.PAYMENTMETHODDISPLAYTEXT)
        
        // Process address components
        const clientAddress = buildAetnaClientAddress(
          record.ADDRESSLINE1,
          record.ADDRESSLINE2,
          record.ADDRESSLINE3,
          record.CITY,
          record.STATE,
          record.POSTALCODE
        )
        
        // Process phone and email
        const clientPhone = processAetnaPhoneNumber(record.PHONE1)
        const clientEmail = record.EMAIL && record.EMAIL.trim() !== '' ? record.EMAIL.trim().toLowerCase() : null
        
        // Process issue age
        const issueAge = toNumber(record.ISSUEAGE)
        
        const policyReport: PolicyReportStaging = {
          client_name: cleanValue(record.INSUREDNAME),
          policy_number: cleanValue(cleanCSVValue(record.POLICYNUMBER)),
          writing_agent_number: cleanValue(cleanCSVValue(record.AGENTNUMBER)),
          agent_name: cleanValue(record.AGENTCOMPLETENAME),
          status: cleanValue(record.STATUSCATEGORY),
          policy_effective_date: policyEffectiveDate ? cleanValue(policyEffectiveDate) : null,
          product: cleanValue(record.LONGDESCRIPTION),
          date_of_birth: birthDate ? cleanValue(birthDate) : null,
          issue_age: issueAge,
          face_value: faceValue,
          payment_method: paymentMethod ? cleanValue(paymentMethod) : null,
          payment_frequency: paymentFrequency ? cleanValue(paymentFrequency) : null,
          payment_cycle_premium: currentModalPremium,
          client_address: clientAddress ? cleanValue(clientAddress) : null,
          client_phone: clientPhone ? cleanValue(clientPhone) : null,
          client_email: clientEmail ? cleanValue(clientEmail) : null,
          state: cleanValue(record.STATE),
          zipcode: cleanValue(record.POSTALCODE),
          annual_premium: currentAnnualPremium,
          client_gender: cleanValue(record.SEX),
          agency_id: agencyId,
          carrier_name: 'Aetna'
        }
        
        policyReports.push(policyReport)
      } catch (rowError) {
        console.error(`Error processing row ${i + 1}:`, rowError, row)
        // Continue processing other rows
      }
    }
    
    return policyReports
  } catch (error) {
    console.error('Aetna Excel parsing error:', error)
    throw new Error(`Failed to parse Aetna Excel: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Processes CSV files and uploads them to the staging table
 * Supports AMAM (American Amicable), RNA (Royal Neighbors), Combined, AHL (American Home Life), Aflac, and Aetna policy reports
 * 
 * @param supabase - Supabase client instance
 * @param agencyId - The agency ID
 * @param uploads - Array of carrier upload objects
 * @returns Promise<{success: boolean, results: any[], errors: string[]}>
 */
async function processCSVUploads(
  supabase: any,
  agencyId: string,
  uploads: Array<{carrier: string, file: File}>
): Promise<{success: boolean, results: any[], errors: string[]}> {
  const results: any[] = []
  const errors: string[] = []

  for (const upload of uploads) {
    try {
      // Validate file
      await validateFile(upload.file)
      
      // Determine carrier type and process accordingly
      const carrierLower = upload.carrier.toLowerCase()
      let policyReports: PolicyReportStaging[] = []
      
      // Add detailed logging for debugging carrier matching
      console.log(`Processing upload - Original carrier: "${upload.carrier}", Lowercase: "${carrierLower}", File: "${upload.file.name}"`)
      
      if (carrierLower === 'american amicable' || carrierLower === 'amam') {
        // Read CSV file content for AMAM
        const csvContent = await upload.file.text()
        // Parse AMAM CSV to policy reports
        policyReports = await parseAMAMCSVToPolicyReports(csvContent, upload.carrier, agencyId)
        
        if (policyReports.length === 0) {
          errors.push(`${upload.carrier}: No valid records found in CSV`)
          continue
        }
        
        console.log(`Successfully processed ${policyReports.length} AMAM records for carrier ${upload.carrier}`)
        
      } else if (carrierLower === 'royal neighbors' || carrierLower === 'rna') {
        // Read CSV file content for RNA
        const csvContent = await upload.file.text()
        // Parse RNA CSV to policy reports
        policyReports = await parseRNACSVToPolicyReports(csvContent, upload.carrier, agencyId)
        
        if (policyReports.length === 0) {
          errors.push(`${upload.carrier}: No valid records found in CSV`)
          continue
        }
        
        console.log(`Successfully processed ${policyReports.length} RNA records for carrier ${upload.carrier}`)
        
      } else if (carrierLower === 'combined' || carrierLower.includes('combined')) {
        // Read CSV file content for Combined
        const csvContent = await upload.file.text()
        // Parse Combined CSV to policy reports
        console.log(`Matched Combined carrier: "${upload.carrier}"`)
        policyReports = await parseCombinedCSVToPolicyReports(csvContent, upload.carrier, agencyId)
        
        if (policyReports.length === 0) {
          errors.push(`${upload.carrier}: No valid records found in CSV`)
          continue
        }
        
        console.log(`Successfully processed ${policyReports.length} Combined records for carrier ${upload.carrier}`)
        
      } else if (carrierLower === 'american home life' || carrierLower === 'ahl') {
        // Parse AHL Excel to policy reports
        console.log(`Matched AHL carrier: "${upload.carrier}"`)
        
        // Convert file to buffer for Excel processing
        const excelBuffer = Buffer.from(await upload.file.arrayBuffer())
        policyReports = await parseAHLExcelToPolicyReports(excelBuffer, upload.carrier, agencyId)
        
        if (policyReports.length === 0) {
          errors.push(`${upload.carrier}: No valid records found in Excel file`)
          continue
        }
        
        console.log(`Successfully processed ${policyReports.length} AHL records for carrier ${upload.carrier}`)
        
      } else if (carrierLower === 'aflac') {
        // Parse Aflac Excel to policy reports
        console.log(`Matched Aflac carrier: "${upload.carrier}"`)
        
        // Convert file to buffer for Excel processing
        const excelBuffer = Buffer.from(await upload.file.arrayBuffer())
        policyReports = await parseAflacExcelToPolicyReports(excelBuffer, upload.carrier, agencyId)
        
        if (policyReports.length === 0) {
          errors.push(`${upload.carrier}: No valid records found in Excel file`)
          continue
        }
        
        console.log(`Successfully processed ${policyReports.length} Aflac records for carrier ${upload.carrier}`)
        
      } else if (carrierLower === 'aetna') {
        // Parse Aetna Excel to policy reports
        console.log(`Matched Aetna carrier: "${upload.carrier}"`)
        
        // Convert file to buffer for Excel processing
        const excelBuffer = Buffer.from(await upload.file.arrayBuffer())
        policyReports = await parseAetnaExcelToPolicyReports(excelBuffer, upload.carrier, agencyId)
        
        if (policyReports.length === 0) {
          errors.push(`${upload.carrier}: No valid records found in Excel file`)
          continue
        }
        
        console.log(`Successfully processed ${policyReports.length} Aetna records for carrier ${upload.carrier}`)
        
      } else {
        console.log(`No carrier match found for: "${upload.carrier}" (lowercase: "${carrierLower}")`)
        errors.push(`${upload.carrier}: Only American Amicable (AMAM), Royal Neighbors (RNA), Combined, American Home Life (AHL), Aflac, and Aetna policy reports are currently supported for staging`)
        continue
      }

      // Upload to staging table
      const uploadResult = await uploadPolicyReportsToStaging(supabase, policyReports)

      if (uploadResult.success) {
        results.push({
          carrier: upload.carrier,
          fileName: upload.file.name,
          recordsProcessed: policyReports.length,
          recordsInserted: uploadResult.insertedCount || policyReports.length
        })
      } else {
        errors.push(`${upload.carrier}: ${uploadResult.error}`)
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      errors.push(`${upload.carrier}: ${errorMessage}`)
    }
  }

  return {
    success: errors.length === 0,
    results,
    errors
  }
}

/**
 * Main POST handler for the staging endpoint
 * Handles authentication, CSV processing, and database insertion
 */
export async function POST(request: NextRequest) {
  try {
    // Initialize Supabase clients
    const supabase = createAdminClient()
    const userClient = await createServerClient()

    // Authenticate user
    const { data: { user }, error: authError } = await userClient.auth.getUser()

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized', detail: 'User authentication failed' },
        { status: 401 }
      )
    }

    // Get agency ID
    const agencyId = await getAgencyId(supabase, user.id)

    // Parse form data
    const formData = await request.formData()
    const uploads: Array<{carrier: string, file: File}> = []

    // Extract files from form data
    console.log('Extracting files from form data...')
    for (const [key, value] of formData.entries()) {
      console.log(`Form field: "${key}", Value type: ${typeof value}, Is File: ${value instanceof File}`)
      if (value instanceof File && value.size > 0) {
        // Extract carrier name from the key (assuming format like "carrier_Aetna")
        const carrierMatch = key.match(/carrier_(.+)/)
        if (carrierMatch) {
          const extractedCarrier = carrierMatch[1]
          console.log(`Extracted carrier: "${extractedCarrier}" from field: "${key}"`)
          uploads.push({
            carrier: extractedCarrier,
            file: value
          })
        } else {
          console.log(`No carrier match found for field: "${key}"`)
        }
      }
    }
    
    console.log(`Found ${uploads.length} uploads:`, uploads.map(u => ({ carrier: u.carrier, fileName: u.file.name })))
    
    // Check if any files were uploaded
    if (uploads.length === 0) {
      return NextResponse.json(
        { error: 'No files uploaded', detail: 'Please upload at least one CSV file' },
        { status: 400 }
      )
    }

    // Process CSV uploads
    const uploadResults = await processCSVUploads(supabase, agencyId, uploads)

    // Calculate total records processed
    const totalRecordsProcessed = uploadResults.results.reduce((sum, result) => sum + result.recordsProcessed, 0)
    const totalRecordsInserted = uploadResults.results.reduce((sum, result) => sum + result.recordsInserted, 0)
    
    // Trigger orchestrate_policy_report_ingest RPC function AFTER staging is fully complete
    let orchestrationResult = null
    if (uploadResults.success && totalRecordsInserted > 0) {
      try {
        console.log(`Triggering orchestrate_policy_report_ingest RPC function for agency ${agencyId} with ${totalRecordsInserted} records`)
        
        const { data: orchestrationData, error: orchestrationError } = await supabase
          .rpc('orchestrate_policy_report_ingest')
        
        if (orchestrationError) {
          console.error('Error calling orchestrate_policy_report_ingest RPC:', orchestrationError)
          orchestrationResult = {
            success: false,
            error: orchestrationError.message
          }
        } else {
          console.log('Successfully executed orchestrate_policy_report_ingest RPC:', orchestrationData)
          orchestrationResult = {
            success: true,
            data: orchestrationData
          }
        }
      } catch (rpcError) {
        console.error('Exception calling orchestrate_policy_report_ingest RPC:', rpcError)
        orchestrationResult = {
          success: false,
          error: rpcError instanceof Error ? rpcError.message : 'Unknown RPC error'
        }
      }
    } else {
      console.log('Skipping orchestrate_policy_report_ingest RPC - no successful uploads or no records inserted')
    }
    
    // Prepare response
    const response = {
      success: uploadResults.success,
      message: uploadResults.success
        ? `Successfully processed ${uploadResults.results.length} file(s) and inserted ${totalRecordsInserted} records into staging table`
        : 'Some files failed to process',
      agencyId,
      totalRecordsProcessed,
      totalRecordsInserted,
      results: uploadResults.results,
      errors: uploadResults.errors,
      orchestration: orchestrationResult
    }

    return NextResponse.json(response, {
      status: uploadResults.success ? 200 : 207 // 207 = Multi-Status for partial success
    })

  } catch (error) {
    console.error('Staging API error:', error)

    return NextResponse.json(
      {
        error: 'Internal Server Error',
        detail: error instanceof Error ? error.message : 'An unexpected error occurred during CSV processing'
      },
      { status: 500 }
    )
  }
}

/**
 * GET handler for retrieving staging data
 * Can be used to check existing staging records or get processing history
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = createAdminClient()
    const userClient = await createServerClient()

    // Authenticate user
    const { data: { user }, error: authError } = await userClient.auth.getUser()

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized', detail: 'User authentication failed' },
        { status: 401 }
      )
    }

    const agencyId = await getAgencyId(supabase, user.id)

    // Get query parameters
    const { searchParams } = new URL(request.url)
    const carrier = searchParams.get('carrier')
    const limit = parseInt(searchParams.get('limit') || '100')

    // Build query
    let query = supabase
      .from('policy_report_staging')
      .select('*')
      .eq('agency_id', agencyId)
      .order('created_at', { ascending: false })
      .limit(limit)

    if (carrier) {
      query = query.eq('carrier_name', carrier)
    }

    const { data: records, error } = await query

    if (error) {
      console.error('Error fetching staging records:', error)
      return NextResponse.json(
        { error: 'Failed to fetch records', detail: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      agencyId,
      carrier: carrier || 'all',
      records: records || [],
      count: records?.length || 0
    })

  } catch (error) {
    console.error('Get staging records API error:', error)

    return NextResponse.json(
      {
        error: 'Internal Server Error',
        detail: error instanceof Error ? error.message : 'An unexpected error occurred'
      },
      { status: 500 }
    )
  }
}

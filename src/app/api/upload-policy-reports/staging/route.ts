// API ROUTE: /api/upload-policy-reports/staging
// This endpoint handles parsing CSV files and uploading them to the policy_report_staging table

import { createServerClient, createAdminClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Papa from 'papaparse'  // For CSV parsing
import * as XLSX from 'xlsx'  // For Excel parsing

// TypeScript interface matching the policy_report_staging table structure
export interface PolicyReportStaging {
  // id is auto-generated by the database, so we don't include it in our interface
  client_name: string
  policy_number: string
  writing_agent_number: string
  agent_name: string
  status: string
  policy_effective_date: string // Will be converted to date format
  product?: string
  date_of_birth?: string | null
  issue_age?: number | null
  face_value?: number | null
  payment_method?: string | null
  payment_frequency?: string | null
  payment_cycle_premium?: number | null
  client_address?: string | null
  client_phone?: string | null
  client_email?: string | null
  state?: string | null
  zipcode?: string | null
  annual_premium?: number | null
  client_gender?: string | null
  agency_id: string
  carrier_name: string
}

// AMAM-specific CSV structure interface
interface AMAMPolicyData {
  WritingAgent: string;
  AgentName: string;
  Company: string;
  Policy: string;
  Status: string;        // ← Used for persistency impact
  DOB: string;
  PolicyDate: string;    // ← Used for time buckets
  PaidtoDate: string;    // ← Used for DeathClaim calculation
  RecvDate: string;
  LastName: string;
  FirstName: string;
  MI: string;
  Plan: string;
  Face: string;
  Form: string;
  Mode: string;
  ModePrem: string;
  Address1: string;
  Address2: string;
  Address3: string;
  Address4: string;
  State: string;
  Zip: string;
  Phone: string;
  Email: string;
  'App Date': string;
  WrtPct: string;
}

/**
 * Retrieves the agency ID for the current user
 *
 * @param supabase - Supabase client instance
 * @param userId - The authenticated user's ID (auth_user_id)
 * @returns Promise<string> - The agency ID
 */
async function getAgencyId(supabase: any, userId: string): Promise<string> {
  try {
    const { data: user, error } = await supabase
      .from('users')
      .select('agency_id')
      .eq('auth_user_id', userId)
      .single()

    if (error || !user) {
      throw new Error('Failed to fetch user agency')
    }

    if (!user.agency_id) {
      throw new Error('User is not associated with an agency')
    }

    return user.agency_id
  } catch (error) {
    console.error('Error fetching agency ID:', error)
    throw error instanceof Error ? error : new Error('Failed to retrieve agency ID')
  }
}

/**
 * Validates the uploaded file to ensure it meets requirements
 * Checks file type, size, and basic structure
 *
 * @param file - The uploaded file object
 * @returns Promise<boolean> - True if file is valid
 */
async function validateFile(file: File): Promise<boolean> {
  try {
    // Check file type - only allow CSV files for staging
    const allowedTypes = ['text/csv']

    if (!allowedTypes.includes(file.type)) {
      throw new Error(`Invalid file type: ${file.type}. Only CSV files are allowed for staging.`)
    }

    // Check file size - limit to 10MB
    const maxSize = 10 * 1024 * 1024 // 10MB in bytes
    if (file.size > maxSize) {
      throw new Error(`File size exceeds limit. Maximum size is 10MB.`)
    }

    // Check if file has content
    if (file.size === 0) {
      throw new Error('File is empty')
    }

    return true
  } catch (error) {
    console.error('File validation error:', error)
    throw error
  }
}

/**
 * Validates AMAM CSV structure and checks for required columns
 *
 * @param headers - Array of column headers from CSV
 * @returns {isValid: boolean, error?: string}
 */
function validateAMAMCSVStructure(headers: string[]): {isValid: boolean, error?: string} {
  // Check if Company column exists and contains AMAM data
  const companyIndex = headers.findIndex(h => h.toLowerCase().includes('company'))
  if (companyIndex === -1) {
    return { isValid: false, error: 'Failed to parse policy report, missing Company column' }
  }

  // Required columns for AMAM policy reports
  const requiredColumns = [
    'WritingAgent', 'AgentName', 'Policy', 'Status', 'DOB', 'PolicyDate',
    'LastName', 'FirstName', 'Plan', 'Face', 'Form', 'Mode', 'ModePrem',
    'Address1', 'State', 'Zip', 'Phone'
  ]

  const missingColumns = requiredColumns.filter(col =>
    !headers.some(header => header.toLowerCase() === col.toLowerCase())
  )

  if (missingColumns.length > 0) {
    return {
      isValid: false,
      error: `Failed to parse policy report, missing columns: ${missingColumns.join(', ')}`
    }
  }

  return { isValid: true }
}

/**
 * Formats agent name from "LastName/FirstName Middle Initial" to "FirstName Middle Initial LastName"
 *
 * @param agentName - The agent name in AMAM format
 * @returns string - Formatted agent name
 */
function formatAgentName(agentName: string): string {
  if (!agentName || agentName.trim() === '') return ''

  // Split by slash to separate last name and first name + middle initial
  const parts = agentName.split('/')
  if (parts.length !== 2) return agentName // Return original if format is unexpected

  const lastName = parts[0].trim()
  const firstNameAndMI = parts[1].trim()

  // Capitalize only first letter of each word
  const capitalizeWords = (str: string) =>
    str.toLowerCase().split(' ').map(word =>
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ')

  return `${capitalizeWords(firstNameAndMI)} ${capitalizeWords(lastName)}`
}

/**
 * Converts MM/DD/YYYY date string to YYYY-MM-DD format
 *
 * @param dateString - Date in MM/DD/YYYY format
 * @returns string - Date in YYYY-MM-DD format or empty string if invalid
 */
function convertDateFormat(dateString: string): string {
  if (!dateString || dateString.trim() === '') return ''

  try {
    // Parse MM/DD/YYYY format
    const parts = dateString.split('/')
    if (parts.length !== 3) return ''

    const month = parts[0].padStart(2, '0')
    const day = parts[1].padStart(2, '0')
    const year = parts[2]

    // Validate date
    const date = new Date(`${year}-${month}-${day}`)
    if (isNaN(date.getTime())) return ''

    return `${year}-${month}-${day}`
  } catch (error) {
    return ''
  }
}

/**
 * Calculates issue age from policy date and date of birth
 *
 * @param policyDate - Policy effective date
 * @param dob - Date of birth
 * @returns number | null - Age in years, rounded to nearest whole number
 */
function calculateIssueAge(policyDate: string, dob: string): number | null {
  if (!policyDate || !dob) return null

  try {
    const policy = new Date(policyDate)
    const birth = new Date(dob)

    if (isNaN(policy.getTime()) || isNaN(birth.getTime())) return null

    const ageInMs = policy.getTime() - birth.getTime()
    const ageInYears = ageInMs / (365.25 * 24 * 60 * 60 * 1000) // Account for leap years

    return Math.round(ageInYears)
  } catch (error) {
    return null
  }
}

/**
 * Safely converts string to number, removing commas and dollar signs
 *
 * @param value - String value to convert
 * @returns number | null - Converted number or null if invalid
 */
function toNumber(value: string): number | null {
  if (!value || value.trim() === '') return null
  const num = parseFloat(value.replace(/[,$]/g, ''))
  return isNaN(num) ? null : num
}

/**
 * Builds client address from address components
 *
 * @param address1 - First address line
 * @param address2 - Second address line
 * @param address3 - Third address line
 * @param address4 - Fourth address line
 * @returns string | null - Combined address or null if all empty
 */
function buildClientAddress(address1: string, address2: string, address3: string, address4: string): string | null {
  const addressParts = [address1, address2, address3, address4]
    .filter(part => part && part.trim() !== '')
    .map(part => part.trim())

  return addressParts.length > 0 ? addressParts.join(' ') : null
}

/**
 * Standardizes client name capitalization - only first letter of each word capitalized
 *
 * @param firstName - First name
 * @param middleInitial - Middle initial
 * @param lastName - Last name
 * @returns string - Properly capitalized client name
 */
function standardizeClientName(firstName: string, middleInitial: string, lastName: string): string {
  const capitalizeWord = (word: string) => {
    if (!word || word.trim() === '') return ''
    return word.trim().toLowerCase().charAt(0).toUpperCase() + word.trim().toLowerCase().slice(1)
  }

  const parts = [
    capitalizeWord(firstName),
    capitalizeWord(middleInitial),
    capitalizeWord(lastName)
  ].filter(part => part !== '')

  return parts.join(' ')
}

/**
 * Normalizes payment frequency values
 *
 * @param mode - Payment mode/frequency value
 * @returns string | null - Normalized payment frequency
 */
function normalizePaymentFrequency(mode: string): string | null {
  if (!mode || mode.trim() === '') return null

  const normalizedMode = mode.trim().toLowerCase()

  // Standardize common variations
  if (normalizedMode.includes('monthly') || normalizedMode === 'month') {
    return 'Monthly'
  }
  if (normalizedMode.includes('quarterly') || normalizedMode === 'quarter') {
    return 'Quarterly'
  }
  if (normalizedMode.includes('semi') || normalizedMode.includes('semi-annual')) {
    return 'Semi-Annual'
  }
  if (normalizedMode.includes('annual') || normalizedMode === 'year') {
    return 'Annual'
  }

  // Return original value with proper capitalization if no match
  return mode.trim().charAt(0).toUpperCase() + mode.trim().slice(1).toLowerCase()
}

/**
 * Standardizes phone number - removes all non-numeric characters
 *
 * @param phone - Phone number string
 * @returns string | null - Cleaned phone number with only digits
 */
function standardizePhoneNumber(phone: string): string | null {
  if (!phone || phone.trim() === '') return null

  // Remove all non-numeric characters (dashes, spaces, parentheses, etc.)
  const cleanedPhone = phone.replace(/\D/g, '')

  // Return null if no digits found
  return cleanedPhone.length > 0 ? cleanedPhone : null
}

/**
 * Standardizes email - converts to lowercase
 *
 * @param email - Email string
 * @returns string | null - Lowercase email or null if empty
 */
function standardizeEmail(email: string): string | null {
  if (!email || email.trim() === '') return null

  return email.trim().toLowerCase()
}

/**
 * Cleans CSV values - removes =("value") syntax that appears in CSV data
 *
 * @param value - Value from CSV that might have =("value") format
 * @returns string - Cleaned value
 */
function cleanCSVValue(value: string): string {
  console.log(`Original CSV value: "${value}"`)

  if (!value || value.trim() === '') {
    console.log('Value is empty, returning empty string')
    return ''
  }

  const trimmedValue = value.trim()
  console.log(`Trimmed value: "${trimmedValue}"`)

  // Handle CSV format like =("0110097180")
  if (trimmedValue.match(/^=\("([^"]+)"\)$/)) {
    const match = trimmedValue.match(/^=\("([^"]+)"\)$/)
    const extractedValue = match ? match[1] : ''
    console.log(`Extracted value from CSV =("...") format: "${extractedValue}"`)
    return extractedValue
  }

  console.log(`Returning original value: "${trimmedValue}"`)
  return trimmedValue
}

/**
 * Parses AMAM CSV content and converts it to PolicyReportStaging objects
 *
 * @param csvContent - The CSV file content as string
 * @param carrierName - The carrier name
 * @param agencyId - The agency ID
 * @returns Promise<PolicyReportStaging[]> - Array of parsed policy reports
 */
async function parseAMAMCSVToPolicyReports(
  csvContent: string,
  carrierName: string,
  agencyId: string
): Promise<PolicyReportStaging[]> {
  try {
    // Parse CSV content using Papa Parse
    const parseResult = Papa.parse<AMAMPolicyData>(csvContent, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => header.trim()
    })

    if (parseResult.errors && parseResult.errors.length > 0) {
      console.error('Papa Parse errors:', parseResult.errors)
      throw new Error(`CSV parsing errors: ${parseResult.errors.map((e: any) => e.message).join(', ')}`)
    }

    const records = parseResult.data
    if (records.length === 0) {
      throw new Error('No data found in CSV file')
    }

    // Validate CSV structure
    const headers = Object.keys(records[0])
    const validation = validateAMAMCSVStructure(headers)
    if (!validation.isValid) {
      throw new Error(validation.error)
    }

    // Check if this is actually AMAM data by verifying Company column exists
    const firstRecord = records[0]
    if (!firstRecord.Company) {
      throw new Error('You uploaded the wrong company\'s policy report to the AMAM section')
    }

    // Map AMAM records to PolicyReportStaging objects
    const policyReports: PolicyReportStaging[] = []

    for (let i = 0; i < records.length; i++) {
      const record = records[i]

      try {
        // Check for required fields - TODO: Remove console.log when productionalizing
        const requiredFields = ['FirstName', 'LastName', 'Policy', 'WritingAgent', 'AgentName', 'Status', 'PolicyDate']
        const missingFields = requiredFields.filter(field => !record[field as keyof AMAMPolicyData] || record[field as keyof AMAMPolicyData].toString().trim() === '')

        if (missingFields.length > 0) {
          console.log(`Row ${i + 1} missing required fields: ${missingFields.join(', ')}`, record)
          continue // Skip this row but continue processing others
        }

        // Convert dates
        const policyDate = convertDateFormat(record.PolicyDate)
        const dobDate = convertDateFormat(record.DOB)

        // Calculate issue age
        const issueAge = calculateIssueAge(policyDate, dobDate)

        // Build client name with proper capitalization
        const clientName = standardizeClientName(record.FirstName, record.MI || '', record.LastName)

        // Format agent name
        const formattedAgentName = formatAgentName(record.AgentName)

        // Build address
        const clientAddress = buildClientAddress(record.Address1, record.Address2, record.Address3, record.Address4)

        // Normalize payment frequency
        const normalizedPaymentFrequency = normalizePaymentFrequency(record.Mode)

        // Standardize phone and email
        const standardizedPhone = standardizePhoneNumber(record.Phone)
        const standardizedEmail = standardizeEmail(record.Email)

        // Calculate annual premium
        const modePrem = toNumber(record.ModePrem)
        const annualPremium = modePrem ? modePrem * 12 : null

        const policyReport: PolicyReportStaging = {
          client_name: clientName,
          policy_number: cleanCSVValue(record.Policy),
          writing_agent_number: cleanCSVValue(record.WritingAgent),
          agent_name: formattedAgentName,
          status: record.Status,
          policy_effective_date: policyDate,
          product: record.Plan,
          date_of_birth: dobDate || null, // Store as date string (YYYY-MM-DD format)
          issue_age: issueAge,
          face_value: toNumber(record.Face),
          payment_method: record.Form || null,
          payment_frequency: normalizedPaymentFrequency,
          payment_cycle_premium: modePrem,
          client_address: clientAddress,
          client_phone: standardizedPhone,
          client_email: standardizedEmail,
          state: record.State || null,
          zipcode: record.Zip || null,
          annual_premium: annualPremium,
          client_gender: null, // No gender data in AMAM
          agency_id: agencyId,
          carrier_name: 'American Amicable / Occidental'
        }

        policyReports.push(policyReport)
      } catch (rowError) {
        console.error(`Error processing row ${i + 1}:`, rowError, record)
        // Continue processing other rows
      }
    }

    return policyReports
  } catch (error) {
    console.error('AMAM CSV parsing error:', error)
    throw new Error(`Failed to parse AMAM CSV: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Uploads policy reports to the staging table
 *
 * @param supabase - Supabase client instance
 * @param policyReports - Array of policy reports to insert
 * @returns Promise<{success: boolean, insertedCount?: number, error?: string}>
 */
async function uploadPolicyReportsToStaging(
  supabase: any,
  policyReports: PolicyReportStaging[]
): Promise<{success: boolean, insertedCount?: number, error?: string}> {
  try {
    // Insert policy reports into staging table
    const { data, error } = await supabase
      .from('policy_report_staging')
      .insert(policyReports)
      .select()

    if (error) {
      console.error('Database insert error:', error)
      return { success: false, error: error.message }
    }

    return {
      success: true,
      insertedCount: data?.length || policyReports.length
    }
  } catch (error) {
    console.error('Upload to staging error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error during staging upload'
    }
  }
}

/**
 * Processes CSV files and uploads them to the staging table
 * Currently only supports AMAM (American Amicable) policy reports
 *
 * @param supabase - Supabase client instance
 * @param agencyId - The agency ID
 * @param uploads - Array of carrier upload objects
 * @returns Promise<{success: boolean, results: any[], errors: string[]}>
 */
async function processCSVUploads(
  supabase: any,
  agencyId: string,
  uploads: Array<{carrier: string, file: File}>
): Promise<{success: boolean, results: any[], errors: string[]}> {
  const results: any[] = []
  const errors: string[] = []

  for (const upload of uploads) {
    try {
      // Validate file
      await validateFile(upload.file)

      // Read file content
      const csvContent = await upload.file.text()

      // Check if this is AMAM (American Amicable) data
      if (upload.carrier.toLowerCase() !== 'american amicable' && upload.carrier.toLowerCase() !== 'amam') {
        errors.push(`${upload.carrier}: Only American Amicable (AMAM) policy reports are currently supported for staging`)
        continue
      }

      // Parse AMAM CSV to policy reports
      const policyReports = await parseAMAMCSVToPolicyReports(csvContent, upload.carrier, agencyId)

      if (policyReports.length === 0) {
        errors.push(`${upload.carrier}: No valid records found in CSV`)
        continue
      }

      // Upload to staging table
      const uploadResult = await uploadPolicyReportsToStaging(supabase, policyReports)

      if (uploadResult.success) {
        results.push({
          carrier: upload.carrier,
          fileName: upload.file.name,
          recordsProcessed: policyReports.length,
          recordsInserted: uploadResult.insertedCount || policyReports.length
        })

        console.log(`Successfully processed ${policyReports.length} AMAM records for carrier ${upload.carrier}`)
      } else {
        errors.push(`${upload.carrier}: ${uploadResult.error}`)
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      errors.push(`${upload.carrier}: ${errorMessage}`)
    }
  }

  return {
    success: errors.length === 0,
    results,
    errors
  }
}

/**
 * Main POST handler for the staging endpoint
 * Handles authentication, CSV processing, and database insertion
 */
export async function POST(request: NextRequest) {
  try {
    // Initialize Supabase clients
    const supabase = createAdminClient()
    const userClient = await createServerClient()

    // Authenticate user
    const { data: { user }, error: authError } = await userClient.auth.getUser()

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized', detail: 'User authentication failed' },
        { status: 401 }
      )
    }

    // Get agency ID
    const agencyId = await getAgencyId(supabase, user.id)

    // Parse form data
    const formData = await request.formData()
    const uploads: Array<{carrier: string, file: File}> = []

    // Extract files from form data
    for (const [key, value] of formData.entries()) {
      if (value instanceof File && value.size > 0) {
        // Extract carrier name from the key (assuming format like "carrier_Aetna")
        const carrierMatch = key.match(/carrier_(.+)/)
        if (carrierMatch) {
          uploads.push({
            carrier: carrierMatch[1],
            file: value
          })
        }
      }
    }

    // Check if any files were uploaded
    if (uploads.length === 0) {
      return NextResponse.json(
        { error: 'No files uploaded', detail: 'Please upload at least one CSV file' },
        { status: 400 }
      )
    }

    // Process CSV uploads
    const uploadResults = await processCSVUploads(supabase, agencyId, uploads)

    // Calculate total records processed
    const totalRecordsProcessed = uploadResults.results.reduce((sum, result) => sum + result.recordsProcessed, 0)
    const totalRecordsInserted = uploadResults.results.reduce((sum, result) => sum + result.recordsInserted, 0)

    // Prepare response
    const response = {
      success: uploadResults.success,
      message: uploadResults.success
        ? `Successfully processed ${uploadResults.results.length} file(s) and inserted ${totalRecordsInserted} records into staging table`
        : 'Some files failed to process',
      agencyId,
      totalRecordsProcessed,
      totalRecordsInserted,
      results: uploadResults.results,
      errors: uploadResults.errors
    }

    return NextResponse.json(response, {
      status: uploadResults.success ? 200 : 207 // 207 = Multi-Status for partial success
    })

  } catch (error) {
    console.error('Staging API error:', error)

    return NextResponse.json(
      {
        error: 'Internal Server Error',
        detail: error instanceof Error ? error.message : 'An unexpected error occurred during CSV processing'
      },
      { status: 500 }
    )
  }
}

/**
 * GET handler for retrieving staging data
 * Can be used to check existing staging records or get processing history
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = createAdminClient()
    const userClient = await createServerClient()

    // Authenticate user
    const { data: { user }, error: authError } = await userClient.auth.getUser()

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized', detail: 'User authentication failed' },
        { status: 401 }
      )
    }

    const agencyId = await getAgencyId(supabase, user.id)

    // Get query parameters
    const { searchParams } = new URL(request.url)
    const carrier = searchParams.get('carrier')
    const limit = parseInt(searchParams.get('limit') || '100')

    // Build query
    let query = supabase
      .from('policy_report_staging')
      .select('*')
      .eq('agency_id', agencyId)
      .order('created_at', { ascending: false })
      .limit(limit)

    if (carrier) {
      query = query.eq('carrier_name', carrier)
    }

    const { data: records, error } = await query

    if (error) {
      console.error('Error fetching staging records:', error)
      return NextResponse.json(
        { error: 'Failed to fetch records', detail: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      agencyId,
      carrier: carrier || 'all',
      records: records || [],
      count: records?.length || 0
    })

  } catch (error) {
    console.error('Get staging records API error:', error)

    return NextResponse.json(
      {
        error: 'Internal Server Error',
        detail: error instanceof Error ? error.message : 'An unexpected error occurred'
      },
      { status: 500 }
    )
  }
}
